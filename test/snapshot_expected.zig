//! Generated by zig-wayland

const std = @import("std");
const assert = std.debug.assert;
const posix = std.posix;

pub const client = struct {
    pub const wl = struct {
        pub const Object = common.Object;
        pub const Message = common.Message;
        pub const Interface = common.Interface;
        pub const list = common.list;
        pub const Array = common.Array;
        pub const Fixed = common.Fixed;
        pub const Argument = common.Argument;

        pub const Proxy = opaque {
            extern fn wl_proxy_create(factory: *Proxy, interface: *const Interface) ?*Proxy;
            pub fn create(factory: *Proxy, interface: *const Interface) error{OutOfMemory}!*Proxy {
                return wl_proxy_create(factory, interface) orelse error.OutOfMemory;
            }

            extern fn wl_proxy_destroy(proxy: *Proxy) void;
            pub const destroy = wl_proxy_destroy;

            extern fn wl_proxy_marshal_array(proxy: *Proxy, opcode: u32, args: ?[*]Argument) void;
            pub const marshal = wl_proxy_marshal_array;

            extern fn wl_proxy_marshal_array_constructor(
                proxy: *Proxy,
                opcode: u32,
                args: [*]Argument,
                interface: *const Interface,
            ) ?*Proxy;
            pub fn marshalConstructor(
                proxy: *Proxy,
                opcode: u32,
                args: [*]Argument,
                interface: *const Interface,
            ) error{OutOfMemory}!*Proxy {
                return wl_proxy_marshal_array_constructor(proxy, opcode, args, interface) orelse
                    error.OutOfMemory;
            }

            extern fn wl_proxy_marshal_array_constructor_versioned(
                proxy: *Proxy,
                opcode: u32,
                args: [*]Argument,
                interface: *const Interface,
                version: u32,
            ) ?*Proxy;
            pub fn marshalConstructorVersioned(
                proxy: *Proxy,
                opcode: u32,
                args: [*]Argument,
                interface: *const Interface,
                version: u32,
            ) error{OutOfMemory}!*Proxy {
                return wl_proxy_marshal_array_constructor_versioned(proxy, opcode, args, interface, version) orelse
                    error.OutOfMemory;
            }

            const DispatcherFn = fn (
                implementation: ?*const anyopaque,
                proxy: *Proxy,
                opcode: u32,
                message: *const Message,
                args: [*]Argument,
            ) callconv(.c) c_int;
            extern fn wl_proxy_add_dispatcher(
                proxy: *Proxy,
                dispatcher: *const DispatcherFn,
                implementation: ?*const anyopaque,
                data: ?*anyopaque,
            ) c_int;
            pub fn addDispatcher(
                proxy: *Proxy,
                dispatcher: *const DispatcherFn,
                implementation: ?*const anyopaque,
                data: ?*anyopaque,
            ) void {
                const ret = wl_proxy_add_dispatcher(proxy, dispatcher, implementation, data);
                // Since there is no way to remove listeners, adding a listener to
                // the same proxy twice is always a bug, so assert instead of returning
                // an error.
                assert(ret != -1); // If this fails, a listener was already added
            }

            extern fn wl_proxy_get_user_data(proxy: *Proxy) ?*anyopaque;
            pub const getUserData = wl_proxy_get_user_data;

            extern fn wl_proxy_get_version(proxy: *Proxy) u32;
            pub const getVersion = wl_proxy_get_version;

            extern fn wl_proxy_get_id(proxy: *Proxy) u32;
            pub const getId = wl_proxy_get_id;

            extern fn wl_proxy_set_queue(proxy: *Proxy, queue: *EventQueue) void;
            pub const setQueue = wl_proxy_set_queue;
        };

        pub const EventQueue = opaque {
            extern fn wl_event_queue_destroy(queue: *EventQueue) void;
            pub const destroy = wl_event_queue_destroy;
        };

        pub const EglWindow = opaque {
            extern fn wl_egl_window_create(surface: *client.wl.Surface, width: c_int, height: c_int) ?*EglWindow;
            pub fn create(surface: *client.wl.Surface, width: c_int, height: c_int) !*EglWindow {
                // Why do people use int when they require a positive number?
                assert(width > 0 and height > 0);
                return wl_egl_window_create(surface, width, height) orelse error.OutOfMemory;
            }

            extern fn wl_egl_window_destroy(egl_window: *EglWindow) void;
            pub const destroy = wl_egl_window_destroy;

            extern fn wl_egl_window_resize(egl_window: *EglWindow, width: c_int, height: c_int, dx: c_int, dy: c_int) void;
            pub const resize = wl_egl_window_resize;

            extern fn wl_egl_window_get_attached_size(egl_window: *EglWindow, width: *c_int, height: *c_int) void;
            pub const getAttachedSize = wl_egl_window_get_attached_size;
        };

        pub const CursorTheme = opaque {
            extern fn wl_cursor_theme_load(name: ?[*:0]const u8, size: c_int, shm: *client.wl.Shm) ?*CursorTheme;
            pub fn load(name: ?[*:0]const u8, size: i32, shm: *client.wl.Shm) error{LoadThemeFailed}!*CursorTheme {
                return wl_cursor_theme_load(name, @intCast(size), shm) orelse error.LoadThemeFailed;
            }

            extern fn wl_cursor_theme_destroy(wl_cursor_theme: *CursorTheme) void;
            pub const destroy = wl_cursor_theme_destroy;

            extern fn wl_cursor_theme_get_cursor(theme: *CursorTheme, name: [*:0]const u8) ?*Cursor;
            pub const getCursor = wl_cursor_theme_get_cursor;
        };

        pub const Cursor = extern struct {
            image_count: c_uint,
            images: [*]*CursorImage,
            name: [*:0]u8,

            extern fn wl_cursor_frame(cursor: *Cursor, time: u32) c_int;
            pub const frame = wl_cursor_frame;

            extern fn wl_cursor_frame_and_duration(cursor: *Cursor, time: u32, duration: *u32) c_int;
            pub const frameAndDuration = wl_cursor_frame_and_duration;
        };

        pub const CursorImage = extern struct {
            width: u32,
            height: u32,
            hotspot_x: u32,
            hotspot_y: u32,
            delay: u32,

            extern fn wl_cursor_image_get_buffer(image: *CursorImage) ?*client.wl.Buffer;
            pub fn getBuffer(image: *CursorImage) error{OutOfMemory}!*client.wl.Buffer {
                return wl_cursor_image_get_buffer(image) orelse error.OutOfMemory;
            }
        };

        /// The core global object.  This is a special singleton object.  It
        /// is used for internal Wayland protocol features.
        pub const Display = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.display.interface;
            pub const Error = common.wl.display.Error;
            pub fn getId(_display: *Display) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_display)).getId();
            }
            pub fn getVersion(_display: *Display) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_display)).getVersion();
            }
            pub fn getUserData(_display: *Display) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_display)).getUserData();
            }
            pub fn setQueue(_display: *Display, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_display);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// The error event is sent out when a fatal (non-recoverable)
                /// error has occurred.  The object_id argument is the object
                /// where the error occurred, most often in response to a request
                /// to that object.  The code identifies the error and is defined
                /// by the object interface.  As such, each interface defines its
                /// own set of error codes.  The message is a brief description
                /// of the error, for (debugging) convenience.
                @"error": struct {
                    object_id: ?*common.Object,
                    code: u32,
                    message: [*:0]const u8,
                },

                /// This event is used internally by the object ID management
                /// logic. When a client deletes an object that it had created,
                /// the server will send this event to acknowledge that it has
                /// seen the delete request. When the client receives this event,
                /// it will know that it can safely reuse the object ID.
                delete_id: struct {
                    id: u32,
                },
            };
            pub inline fn setListener(
                _display: *Display,
                comptime T: type,
                _listener: *const fn (display: *Display, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_display);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Display, T).dispatcher, _listener, _mut_data);
            }
            /// The sync request asks the server to emit the 'done' event
            /// on the returned wl_callback object.  Since requests are
            /// handled in-order and events are delivered in-order, this can
            /// be used as a barrier to ensure all previous requests and the
            /// resulting events have been handled.
            ///
            /// The object returned by this request will be destroyed by the
            /// compositor after the callback is fired and as such the client must not
            /// attempt to use it after that point.
            ///
            /// The callback_data passed in the callback is undefined and should be ignored.
            pub fn sync(_display: *Display) !*client.wl.Callback {
                const _proxy: *client.wl.Proxy = @ptrCast(_display);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(0, &_args, client.wl.Callback.interface));
            }

            /// This request creates a registry object that allows the client
            /// to list and bind the global objects available from the
            /// compositor.
            ///
            /// It should be noted that the server side resources consumed in
            /// response to a get_registry request can only be released when the
            /// client disconnects, not when the client side proxy is destroyed.
            /// Therefore, clients should invoke get_registry as infrequently as
            /// possible to avoid wasting memory.
            pub fn getRegistry(_display: *Display) !*client.wl.Registry {
                const _proxy: *client.wl.Proxy = @ptrCast(_display);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(1, &_args, client.wl.Registry.interface));
            }
            extern fn wl_display_connect(name: ?[*:0]const u8) ?*Display;
            pub inline fn connect(name: ?[*:0]const u8) error{ConnectFailed}!*Display {
                return wl_display_connect(name) orelse return error.ConnectFailed;
            }

            extern fn wl_display_connect_to_fd(fd: c_int) ?*Display;
            pub inline fn connectToFd(fd: c_int) error{ConnectFailed}!*Display {
                return wl_display_connect_to_fd(fd) orelse return error.ConnectFailed;
            }

            extern fn wl_display_disconnect(display: *Display) void;
            pub const disconnect = wl_display_disconnect;

            extern fn wl_display_get_fd(display: *Display) c_int;
            pub const getFd = wl_display_get_fd;

            extern fn wl_display_dispatch(display: *Display) c_int;
            pub inline fn dispatch(display: *Display) posix.E {
                return posix.errno(wl_display_dispatch(display));
            }

            extern fn wl_display_dispatch_queue(display: *Display, queue: *client.wl.EventQueue) c_int;
            pub inline fn dispatchQueue(display: *Display, queue: *client.wl.EventQueue) posix.E {
                return posix.errno(wl_display_dispatch_queue(display, queue));
            }

            extern fn wl_display_dispatch_pending(display: *Display) c_int;
            pub inline fn dispatchPending(display: *Display) posix.E {
                return posix.errno(wl_display_dispatch_pending(display));
            }

            extern fn wl_display_dispatch_queue_pending(display: *Display, queue: *client.wl.EventQueue) c_int;
            pub inline fn dispatchQueuePending(display: *Display, queue: *client.wl.EventQueue) posix.E {
                return posix.errno(wl_display_dispatch_queue_pending(display, queue));
            }

            extern fn wl_display_roundtrip(display: *Display) c_int;
            pub inline fn roundtrip(display: *Display) posix.E {
                return posix.errno(wl_display_roundtrip(display));
            }

            extern fn wl_display_roundtrip_queue(display: *Display, queue: *client.wl.EventQueue) c_int;
            pub inline fn roundtripQueue(display: *Display, queue: *client.wl.EventQueue) posix.E {
                return posix.errno(wl_display_roundtrip_queue(display, queue));
            }

            extern fn wl_display_flush(display: *Display) c_int;
            pub inline fn flush(display: *Display) posix.E {
                return posix.errno(wl_display_flush(display));
            }

            extern fn wl_display_create_queue(display: *Display) ?*client.wl.EventQueue;
            pub inline fn createQueue(display: *Display) error{OutOfMemory}!*client.wl.EventQueue {
                return wl_display_create_queue(display) orelse error.OutOfMemory;
            }

            extern fn wl_display_get_error(display: *Display) c_int;
            pub const getError = wl_display_get_error;

            extern fn wl_display_prepare_read_queue(display: *Display, queue: *client.wl.EventQueue) c_int;
            /// Succeeds if the queue is empty and returns true.
            /// Fails and returns false if the queue was not empty.
            pub inline fn prepareReadQueue(display: *Display, queue: *client.wl.EventQueue) bool {
                switch (wl_display_prepare_read_queue(display, queue)) {
                    0 => return true,
                    -1 => return false,
                    else => unreachable,
                }
            }

            extern fn wl_display_prepare_read(display: *Display) c_int;
            /// Succeeds if the queue is empty and returns true.
            /// Fails and returns false if the queue was not empty.
            pub inline fn prepareRead(display: *Display) bool {
                switch (wl_display_prepare_read(display)) {
                    0 => return true,
                    -1 => return false,
                    else => unreachable,
                }
            }

            extern fn wl_display_cancel_read(display: *Display) void;
            pub const cancelRead = wl_display_cancel_read;

            extern fn wl_display_read_events(display: *Display) c_int;
            pub inline fn readEvents(display: *Display) posix.E {
                return posix.errno(wl_display_read_events(display));
            }
        };

        /// The singleton global registry object.  The server has a number of
        /// global objects that are available to all clients.  These objects
        /// typically represent an actual object in the server (for example,
        /// an input device) or they are singleton objects that provide
        /// extension functionality.
        ///
        /// When a client creates a registry object, the registry object
        /// will emit a global event for each global currently in the
        /// registry.  Globals come and go as a result of device or
        /// monitor hotplugs, reconfiguration or other events, and the
        /// registry will send out global and global_remove events to
        /// keep the client up to date with the changes.  To mark the end
        /// of the initial burst of events, the client can use the
        /// wl_display.sync request immediately after calling
        /// wl_display.get_registry.
        ///
        /// A client can bind to a global object by using the bind
        /// request.  This creates a client-side handle that lets the object
        /// emit events to the client and lets the client invoke requests on
        /// the object.
        pub const Registry = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.registry.interface;
            pub fn getId(_registry: *Registry) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_registry)).getId();
            }
            pub fn getVersion(_registry: *Registry) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_registry)).getVersion();
            }
            pub fn getUserData(_registry: *Registry) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_registry)).getUserData();
            }
            pub fn setQueue(_registry: *Registry, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_registry);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// Notify the client of global objects.
                ///
                /// The event notifies the client that a global object with
                /// the given name is now available, and it implements the
                /// given version of the given interface.
                global: struct {
                    name: u32,
                    interface: [*:0]const u8,
                    version: u32,
                },

                /// Notify the client of removed global objects.
                ///
                /// This event notifies the client that the global identified
                /// by name is no longer available.  If the client bound to
                /// the global using the bind request, the client should now
                /// destroy that object.
                ///
                /// The object remains valid and requests to the object will be
                /// ignored until the client destroys it, to avoid races between
                /// the global going away and a client sending a request to it.
                global_remove: struct {
                    name: u32,
                },
            };
            pub inline fn setListener(
                _registry: *Registry,
                comptime T: type,
                _listener: *const fn (registry: *Registry, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_registry);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Registry, T).dispatcher, _listener, _mut_data);
            }
            /// Binds a new, client-created object to the server using the
            /// specified name as the identifier.
            pub fn bind(_registry: *Registry, _name: u32, comptime T: type, _version: u32) !*T {
                const version_to_construct = @min(T.generated_version, _version);
                const _proxy: *client.wl.Proxy = @ptrCast(_registry);
                var _args = [_]common.Argument{
                    .{ .u = _name },
                    .{ .s = T.interface.name },
                    .{ .u = version_to_construct },
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructorVersioned(0, &_args, T.interface, version_to_construct));
            }
            pub fn destroy(_registry: *Registry) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_registry);
                _proxy.destroy();
            }
        };

        /// Clients can handle the 'done' event to get notified when
        /// the related request is done.
        ///
        /// Note, because wl_callback objects are created from multiple independent
        /// factory interfaces, the wl_callback interface is frozen at version 1.
        pub const Callback = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.callback.interface;
            pub fn getId(_callback: *Callback) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_callback)).getId();
            }
            pub fn getVersion(_callback: *Callback) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_callback)).getVersion();
            }
            pub fn getUserData(_callback: *Callback) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_callback)).getUserData();
            }
            pub fn setQueue(_callback: *Callback, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_callback);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// Notify the client when the related request is done.
                done: struct {
                    callback_data: u32,
                },
            };
            pub inline fn setListener(
                _callback: *Callback,
                comptime T: type,
                _listener: *const fn (callback: *Callback, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_callback);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Callback, T).dispatcher, _listener, _mut_data);
            }
            pub fn destroy(_callback: *Callback) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_callback);
                _proxy.destroy();
            }
        };

        /// A buffer provides the content for a wl_surface. Buffers are
        /// created through factory interfaces such as wl_shm, wp_linux_buffer_params
        /// (from the linux-dmabuf protocol extension) or similar. It has a width and
        /// a height and can be attached to a wl_surface, but the mechanism by which a
        /// client provides and updates the contents is defined by the buffer factory
        /// interface.
        ///
        /// Color channels are assumed to be electrical rather than optical (in other
        /// words, encoded with a transfer function) unless otherwise specified. If
        /// the buffer uses a format that has an alpha channel, the alpha channel is
        /// assumed to be premultiplied into the electrical color channel values
        /// (after transfer function encoding) unless otherwise specified.
        ///
        /// Note, because wl_buffer objects are created from multiple independent
        /// factory interfaces, the wl_buffer interface is frozen at version 1.
        pub const Buffer = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.buffer.interface;
            pub fn getId(_buffer: *Buffer) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_buffer)).getId();
            }
            pub fn getVersion(_buffer: *Buffer) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_buffer)).getVersion();
            }
            pub fn getUserData(_buffer: *Buffer) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_buffer)).getUserData();
            }
            pub fn setQueue(_buffer: *Buffer, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_buffer);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// Sent when this wl_buffer is no longer used by the compositor.
                ///
                /// For more information on when release events may or may not be sent,
                /// and what consequences it has, please see the description of
                /// wl_surface.attach.
                ///
                /// If a client receives a release event before the frame callback
                /// requested in the same wl_surface.commit that attaches this
                /// wl_buffer to a surface, then the client is immediately free to
                /// reuse the buffer and its backing storage, and does not need a
                /// second buffer for the next surface content update. Typically
                /// this is possible, when the compositor maintains a copy of the
                /// wl_surface contents, e.g. as a GL texture. This is an important
                /// optimization for GL(ES) compositors with wl_shm clients.
                release: void,
            };
            pub inline fn setListener(
                _buffer: *Buffer,
                comptime T: type,
                _listener: *const fn (buffer: *Buffer, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_buffer);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Buffer, T).dispatcher, _listener, _mut_data);
            }
            /// Destroy a buffer. If and how you need to release the backing
            /// storage is defined by the buffer factory interface.
            ///
            /// For possible side-effects to a surface, see wl_surface.attach.
            pub fn destroy(_buffer: *Buffer) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_buffer);
                _proxy.marshal(0, null);
                _proxy.destroy();
            }
        };

        /// A compositor.  This object is a singleton global.  The
        /// compositor is in charge of combining the contents of multiple
        /// surfaces into one displayable output.
        pub const Compositor = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.compositor.interface;
            pub fn getId(_compositor: *Compositor) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_compositor)).getId();
            }
            pub fn getVersion(_compositor: *Compositor) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_compositor)).getVersion();
            }
            pub fn getUserData(_compositor: *Compositor) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_compositor)).getUserData();
            }
            pub fn setQueue(_compositor: *Compositor, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_compositor);
                _proxy.setQueue(_queue);
            }
            /// Ask the compositor to create a new surface.
            pub fn createSurface(_compositor: *Compositor) !*client.wl.Surface {
                const _proxy: *client.wl.Proxy = @ptrCast(_compositor);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(0, &_args, client.wl.Surface.interface));
            }

            /// Ask the compositor to create a new region.
            pub fn createRegion(_compositor: *Compositor) !*client.wl.Region {
                const _proxy: *client.wl.Proxy = @ptrCast(_compositor);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(1, &_args, client.wl.Region.interface));
            }
            pub fn destroy(_compositor: *Compositor) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_compositor);
                _proxy.destroy();
            }
        };

        /// A surface is a rectangular area that may be displayed on zero
        /// or more outputs, and shown any number of times at the compositor's
        /// discretion. They can present wl_buffers, receive user input, and
        /// define a local coordinate system.
        ///
        /// The size of a surface (and relative positions on it) is described
        /// in surface-local coordinates, which may differ from the buffer
        /// coordinates of the pixel content, in case a buffer_transform
        /// or a buffer_scale is used.
        ///
        /// A surface without a "role" is fairly useless: a compositor does
        /// not know where, when or how to present it. The role is the
        /// purpose of a wl_surface. Examples of roles are a cursor for a
        /// pointer (as set by wl_pointer.set_cursor), a drag icon
        /// (wl_data_device.start_drag), a sub-surface
        /// (wl_subcompositor.get_subsurface), and a window as defined by a
        /// shell protocol (e.g. wl_shell.get_shell_surface).
        ///
        /// A surface can have only one role at a time. Initially a
        /// wl_surface does not have a role. Once a wl_surface is given a
        /// role, it is set permanently for the whole lifetime of the
        /// wl_surface object. Giving the current role again is allowed,
        /// unless explicitly forbidden by the relevant interface
        /// specification.
        ///
        /// Surface roles are given by requests in other interfaces such as
        /// wl_pointer.set_cursor. The request should explicitly mention
        /// that this request gives a role to a wl_surface. Often, this
        /// request also creates a new protocol object that represents the
        /// role and adds additional functionality to wl_surface. When a
        /// client wants to destroy a wl_surface, they must destroy this role
        /// object before the wl_surface, otherwise a defunct_role_object error is
        /// sent.
        ///
        /// Destroying the role object does not remove the role from the
        /// wl_surface, but it may stop the wl_surface from "playing the role".
        /// For instance, if a wl_subsurface object is destroyed, the wl_surface
        /// it was created for will be unmapped and forget its position and
        /// z-order. It is allowed to create a wl_subsurface for the same
        /// wl_surface again, but it is not allowed to use the wl_surface as
        /// a cursor (cursor is a different role than sub-surface, and role
        /// switching is not allowed).
        pub const Surface = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.surface.interface;
            pub const Error = common.wl.surface.Error;
            pub fn getId(_surface: *Surface) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_surface)).getId();
            }
            pub fn getVersion(_surface: *Surface) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_surface)).getVersion();
            }
            pub fn getUserData(_surface: *Surface) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_surface)).getUserData();
            }
            pub fn setQueue(_surface: *Surface, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_surface);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// This is emitted whenever a surface's creation, movement, or resizing
                /// results in some part of it being within the scanout region of an
                /// output.
                ///
                /// Note that a surface may be overlapping with zero or more outputs.
                enter: struct {
                    output: ?*client.wl.Output,
                },

                /// This is emitted whenever a surface's creation, movement, or resizing
                /// results in it no longer having any part of it within the scanout region
                /// of an output.
                ///
                /// Clients should not use the number of outputs the surface is on for frame
                /// throttling purposes. The surface might be hidden even if no leave event
                /// has been sent, and the compositor might expect new surface content
                /// updates even if no enter event has been sent. The frame event should be
                /// used instead.
                leave: struct {
                    output: ?*client.wl.Output,
                },
            };
            pub inline fn setListener(
                _surface: *Surface,
                comptime T: type,
                _listener: *const fn (surface: *Surface, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_surface);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Surface, T).dispatcher, _listener, _mut_data);
            }
            /// Deletes the surface and invalidates its object ID.
            pub fn destroy(_surface: *Surface) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_surface);
                _proxy.marshal(0, null);
                _proxy.destroy();
            }

            /// Set a buffer as the content of this surface.
            ///
            /// The new size of the surface is calculated based on the buffer
            /// size transformed by the inverse buffer_transform and the
            /// inverse buffer_scale. This means that at commit time the supplied
            /// buffer size must be an integer multiple of the buffer_scale. If
            /// that's not the case, an invalid_size error is sent.
            ///
            /// The x and y arguments specify the location of the new pending
            /// buffer's upper left corner, relative to the current buffer's upper
            /// left corner, in surface-local coordinates. In other words, the
            /// x and y, combined with the new surface size define in which
            /// directions the surface's size changes. Setting anything other than 0
            /// as x and y arguments is discouraged, and should instead be replaced
            /// with using the separate wl_surface.offset request.
            ///
            /// When the bound wl_surface version is 5 or higher, passing any
            /// non-zero x or y is a protocol violation, and will result in an
            /// 'invalid_offset' error being raised. The x and y arguments are ignored
            /// and do not change the pending state. To achieve equivalent semantics,
            /// use wl_surface.offset.
            ///
            /// Surface contents are double-buffered state, see wl_surface.commit.
            ///
            /// The initial surface contents are void; there is no content.
            /// wl_surface.attach assigns the given wl_buffer as the pending
            /// wl_buffer. wl_surface.commit makes the pending wl_buffer the new
            /// surface contents, and the size of the surface becomes the size
            /// calculated from the wl_buffer, as described above. After commit,
            /// there is no pending buffer until the next attach.
            ///
            /// Committing a pending wl_buffer allows the compositor to read the
            /// pixels in the wl_buffer. The compositor may access the pixels at
            /// any time after the wl_surface.commit request. When the compositor
            /// will not access the pixels anymore, it will send the
            /// wl_buffer.release event. Only after receiving wl_buffer.release,
            /// the client may reuse the wl_buffer. A wl_buffer that has been
            /// attached and then replaced by another attach instead of committed
            /// will not receive a release event, and is not used by the
            /// compositor.
            ///
            /// If a pending wl_buffer has been committed to more than one wl_surface,
            /// the delivery of wl_buffer.release events becomes undefined. A well
            /// behaved client should not rely on wl_buffer.release events in this
            /// case. Alternatively, a client could create multiple wl_buffer objects
            /// from the same backing storage or use a protocol extension providing
            /// per-commit release notifications.
            ///
            /// Destroying the wl_buffer after wl_buffer.release does not change
            /// the surface contents. Destroying the wl_buffer before wl_buffer.release
            /// is allowed as long as the underlying buffer storage isn't re-used (this
            /// can happen e.g. on client process termination). However, if the client
            /// destroys the wl_buffer before receiving the wl_buffer.release event and
            /// mutates the underlying buffer storage, the surface contents become
            /// undefined immediately.
            ///
            /// If wl_surface.attach is sent with a NULL wl_buffer, the
            /// following wl_surface.commit will remove the surface content.
            ///
            /// If a pending wl_buffer has been destroyed, the result is not specified.
            /// Many compositors are known to remove the surface content on the following
            /// wl_surface.commit, but this behaviour is not universal. Clients seeking to
            /// maximise compatibility should not destroy pending buffers and should
            /// ensure that they explicitly remove content from surfaces, even after
            /// destroying buffers.
            pub fn attach(_surface: *Surface, _buffer: ?*client.wl.Buffer, _x: i32, _y: i32) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_surface);
                var _args = [_]common.Argument{
                    .{ .o = @ptrCast(_buffer) },
                    .{ .i = _x },
                    .{ .i = _y },
                };
                _proxy.marshal(1, &_args);
            }

            /// This request is used to describe the regions where the pending
            /// buffer is different from the current surface contents, and where
            /// the surface therefore needs to be repainted. The compositor
            /// ignores the parts of the damage that fall outside of the surface.
            ///
            /// Damage is double-buffered state, see wl_surface.commit.
            ///
            /// The damage rectangle is specified in surface-local coordinates,
            /// where x and y specify the upper left corner of the damage rectangle.
            ///
            /// The initial value for pending damage is empty: no damage.
            /// wl_surface.damage adds pending damage: the new pending damage
            /// is the union of old pending damage and the given rectangle.
            ///
            /// wl_surface.commit assigns pending damage as the current damage,
            /// and clears pending damage. The server will clear the current
            /// damage as it repaints the surface.
            ///
            /// Note! New clients should not use this request. Instead damage can be
            /// posted with wl_surface.damage_buffer which uses buffer coordinates
            /// instead of surface coordinates.
            pub fn damage(_surface: *Surface, _x: i32, _y: i32, _width: i32, _height: i32) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_surface);
                var _args = [_]common.Argument{
                    .{ .i = _x },
                    .{ .i = _y },
                    .{ .i = _width },
                    .{ .i = _height },
                };
                _proxy.marshal(2, &_args);
            }

            /// Request a notification when it is a good time to start drawing a new
            /// frame, by creating a frame callback. This is useful for throttling
            /// redrawing operations, and driving animations.
            ///
            /// When a client is animating on a wl_surface, it can use the 'frame'
            /// request to get notified when it is a good time to draw and commit the
            /// next frame of animation. If the client commits an update earlier than
            /// that, it is likely that some updates will not make it to the display,
            /// and the client is wasting resources by drawing too often.
            ///
            /// The frame request will take effect on the next wl_surface.commit.
            /// The notification will only be posted for one frame unless
            /// requested again. For a wl_surface, the notifications are posted in
            /// the order the frame requests were committed.
            ///
            /// The server must send the notifications so that a client
            /// will not send excessive updates, while still allowing
            /// the highest possible update rate for clients that wait for the reply
            /// before drawing again. The server should give some time for the client
            /// to draw and commit after sending the frame callback events to let it
            /// hit the next output refresh.
            ///
            /// A server should avoid signaling the frame callbacks if the
            /// surface is not visible in any way, e.g. the surface is off-screen,
            /// or completely obscured by other opaque surfaces.
            ///
            /// The object returned by this request will be destroyed by the
            /// compositor after the callback is fired and as such the client must not
            /// attempt to use it after that point.
            ///
            /// The callback_data passed in the callback is the current time, in
            /// milliseconds, with an undefined base.
            pub fn frame(_surface: *Surface) !*client.wl.Callback {
                const _proxy: *client.wl.Proxy = @ptrCast(_surface);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(3, &_args, client.wl.Callback.interface));
            }

            /// This request sets the region of the surface that contains
            /// opaque content.
            ///
            /// The opaque region is an optimization hint for the compositor
            /// that lets it optimize the redrawing of content behind opaque
            /// regions.  Setting an opaque region is not required for correct
            /// behaviour, but marking transparent content as opaque will result
            /// in repaint artifacts.
            ///
            /// The opaque region is specified in surface-local coordinates.
            ///
            /// The compositor ignores the parts of the opaque region that fall
            /// outside of the surface.
            ///
            /// Opaque region is double-buffered state, see wl_surface.commit.
            ///
            /// wl_surface.set_opaque_region changes the pending opaque region.
            /// wl_surface.commit copies the pending region to the current region.
            /// Otherwise, the pending and current regions are never changed.
            ///
            /// The initial value for an opaque region is empty. Setting the pending
            /// opaque region has copy semantics, and the wl_region object can be
            /// destroyed immediately. A NULL wl_region causes the pending opaque
            /// region to be set to empty.
            pub fn setOpaqueRegion(_surface: *Surface, _region: ?*client.wl.Region) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_surface);
                var _args = [_]common.Argument{
                    .{ .o = @ptrCast(_region) },
                };
                _proxy.marshal(4, &_args);
            }

            /// This request sets the region of the surface that can receive
            /// pointer and touch events.
            ///
            /// Input events happening outside of this region will try the next
            /// surface in the server surface stack. The compositor ignores the
            /// parts of the input region that fall outside of the surface.
            ///
            /// The input region is specified in surface-local coordinates.
            ///
            /// Input region is double-buffered state, see wl_surface.commit.
            ///
            /// wl_surface.set_input_region changes the pending input region.
            /// wl_surface.commit copies the pending region to the current region.
            /// Otherwise the pending and current regions are never changed,
            /// except cursor and icon surfaces are special cases, see
            /// wl_pointer.set_cursor and wl_data_device.start_drag.
            ///
            /// The initial value for an input region is infinite. That means the
            /// whole surface will accept input. Setting the pending input region
            /// has copy semantics, and the wl_region object can be destroyed
            /// immediately. A NULL wl_region causes the input region to be set
            /// to infinite.
            pub fn setInputRegion(_surface: *Surface, _region: ?*client.wl.Region) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_surface);
                var _args = [_]common.Argument{
                    .{ .o = @ptrCast(_region) },
                };
                _proxy.marshal(5, &_args);
            }

            /// Surface state (input, opaque, and damage regions, attached buffers,
            /// etc.) is double-buffered. Protocol requests modify the pending state,
            /// as opposed to the active state in use by the compositor.
            ///
            /// A commit request atomically creates a content update from the pending
            /// state, even if the pending state has not been touched. The content
            /// update is placed in a queue until it becomes active. After commit, the
            /// new pending state is as documented for each related request.
            ///
            /// When the content update is applied, the wl_buffer is applied before all
            /// other state. This means that all coordinates in double-buffered state
            /// are relative to the newly attached wl_buffers, except for
            /// wl_surface.attach itself. If there is no newly attached wl_buffer, the
            /// coordinates are relative to the previous content update.
            ///
            /// All requests that need a commit to become effective are documented
            /// to affect double-buffered state.
            ///
            /// Other interfaces may add further double-buffered surface state.
            pub fn commit(_surface: *Surface) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_surface);
                _proxy.marshal(6, null);
            }

            /// This request sets the transformation that the client has already applied
            /// to the content of the buffer. The accepted values for the transform
            /// parameter are the values for wl_output.transform.
            ///
            /// The compositor applies the inverse of this transformation whenever it
            /// uses the buffer contents.
            ///
            /// Buffer transform is double-buffered state, see wl_surface.commit.
            ///
            /// A newly created surface has its buffer transformation set to normal.
            ///
            /// wl_surface.set_buffer_transform changes the pending buffer
            /// transformation. wl_surface.commit copies the pending buffer
            /// transformation to the current one. Otherwise, the pending and current
            /// values are never changed.
            ///
            /// The purpose of this request is to allow clients to render content
            /// according to the output transform, thus permitting the compositor to
            /// use certain optimizations even if the display is rotated. Using
            /// hardware overlays and scanning out a client buffer for fullscreen
            /// surfaces are examples of such optimizations. Those optimizations are
            /// highly dependent on the compositor implementation, so the use of this
            /// request should be considered on a case-by-case basis.
            ///
            /// Note that if the transform value includes 90 or 270 degree rotation,
            /// the width of the buffer will become the surface height and the height
            /// of the buffer will become the surface width.
            ///
            /// If transform is not one of the values from the
            /// wl_output.transform enum the invalid_transform protocol error
            /// is raised.
            pub fn setBufferTransform(_surface: *Surface, _transform: common.wl.output.Transform) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_surface);
                var _args = [_]common.Argument{
                    .{ .i = switch (@typeInfo(common.wl.output.Transform)) {
                        .@"enum" => @as(i32, @intCast(@intFromEnum(_transform))),
                        .@"struct" => @bitCast(_transform),
                        else => unreachable,
                    } },
                };
                _proxy.marshal(7, &_args);
            }

            /// This request sets an optional scaling factor on how the compositor
            /// interprets the contents of the buffer attached to the window.
            ///
            /// Buffer scale is double-buffered state, see wl_surface.commit.
            ///
            /// A newly created surface has its buffer scale set to 1.
            ///
            /// wl_surface.set_buffer_scale changes the pending buffer scale.
            /// wl_surface.commit copies the pending buffer scale to the current one.
            /// Otherwise, the pending and current values are never changed.
            ///
            /// The purpose of this request is to allow clients to supply higher
            /// resolution buffer data for use on high resolution outputs. It is
            /// intended that you pick the same buffer scale as the scale of the
            /// output that the surface is displayed on. This means the compositor
            /// can avoid scaling when rendering the surface on that output.
            ///
            /// Note that if the scale is larger than 1, then you have to attach
            /// a buffer that is larger (by a factor of scale in each dimension)
            /// than the desired surface size.
            ///
            /// If scale is not greater than 0 the invalid_scale protocol error is
            /// raised.
            pub fn setBufferScale(_surface: *Surface, _scale: i32) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_surface);
                var _args = [_]common.Argument{
                    .{ .i = _scale },
                };
                _proxy.marshal(8, &_args);
            }

            /// This request is used to describe the regions where the pending
            /// buffer is different from the current surface contents, and where
            /// the surface therefore needs to be repainted. The compositor
            /// ignores the parts of the damage that fall outside of the surface.
            ///
            /// Damage is double-buffered state, see wl_surface.commit.
            ///
            /// The damage rectangle is specified in buffer coordinates,
            /// where x and y specify the upper left corner of the damage rectangle.
            ///
            /// The initial value for pending damage is empty: no damage.
            /// wl_surface.damage_buffer adds pending damage: the new pending
            /// damage is the union of old pending damage and the given rectangle.
            ///
            /// wl_surface.commit assigns pending damage as the current damage,
            /// and clears pending damage. The server will clear the current
            /// damage as it repaints the surface.
            ///
            /// This request differs from wl_surface.damage in only one way - it
            /// takes damage in buffer coordinates instead of surface-local
            /// coordinates. While this generally is more intuitive than surface
            /// coordinates, it is especially desirable when using wp_viewport
            /// or when a drawing library (like EGL) is unaware of buffer scale
            /// and buffer transform.
            ///
            /// Note: Because buffer transformation changes and damage requests may
            /// be interleaved in the protocol stream, it is impossible to determine
            /// the actual mapping between surface and buffer damage until
            /// wl_surface.commit time. Therefore, compositors wishing to take both
            /// kinds of damage into account will have to accumulate damage from the
            /// two requests separately and only transform from one to the other
            /// after receiving the wl_surface.commit.
            pub fn damageBuffer(_surface: *Surface, _x: i32, _y: i32, _width: i32, _height: i32) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_surface);
                var _args = [_]common.Argument{
                    .{ .i = _x },
                    .{ .i = _y },
                    .{ .i = _width },
                    .{ .i = _height },
                };
                _proxy.marshal(9, &_args);
            }

            /// The x and y arguments specify the location of the new pending
            /// buffer's upper left corner, relative to the current buffer's upper
            /// left corner, in surface-local coordinates. In other words, the
            /// x and y, combined with the new surface size define in which
            /// directions the surface's size changes.
            ///
            /// The exact semantics of wl_surface.offset are role-specific. Refer to
            /// the documentation of specific roles for more information.
            ///
            /// Surface location offset is double-buffered state, see
            /// wl_surface.commit.
            ///
            /// This request is semantically equivalent to and the replaces the x and y
            /// arguments in the wl_surface.attach request in wl_surface versions prior
            /// to 5. See wl_surface.attach for details.
            pub fn offset(_surface: *Surface, _x: i32, _y: i32) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_surface);
                var _args = [_]common.Argument{
                    .{ .i = _x },
                    .{ .i = _y },
                };
                _proxy.marshal(10, &_args);
            }
        };

        /// A region object describes an area.
        ///
        /// Region objects are used to describe the opaque and input
        /// regions of a surface.
        pub const Region = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.region.interface;
            pub fn getId(_region: *Region) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_region)).getId();
            }
            pub fn getVersion(_region: *Region) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_region)).getVersion();
            }
            pub fn getUserData(_region: *Region) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_region)).getUserData();
            }
            pub fn setQueue(_region: *Region, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_region);
                _proxy.setQueue(_queue);
            }
            /// Destroy the region.  This will invalidate the object ID.
            pub fn destroy(_region: *Region) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_region);
                _proxy.marshal(0, null);
                _proxy.destroy();
            }

            /// Add the specified rectangle to the region.
            pub fn add(_region: *Region, _x: i32, _y: i32, _width: i32, _height: i32) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_region);
                var _args = [_]common.Argument{
                    .{ .i = _x },
                    .{ .i = _y },
                    .{ .i = _width },
                    .{ .i = _height },
                };
                _proxy.marshal(1, &_args);
            }

            /// Subtract the specified rectangle from the region.
            pub fn subtract(_region: *Region, _x: i32, _y: i32, _width: i32, _height: i32) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_region);
                var _args = [_]common.Argument{
                    .{ .i = _x },
                    .{ .i = _y },
                    .{ .i = _width },
                    .{ .i = _height },
                };
                _proxy.marshal(2, &_args);
            }
        };

        /// A singleton global object that provides support for shared
        /// memory.
        ///
        /// Clients can create wl_shm_pool objects using the create_pool
        /// request.
        ///
        /// On binding the wl_shm object one or more format events
        /// are emitted to inform clients about the valid pixel formats
        /// that can be used for buffers.
        pub const Shm = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.shm.interface;
            pub const Error = common.wl.shm.Error;
            pub const Format = common.wl.shm.Format;
            pub fn getId(_shm: *Shm) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_shm)).getId();
            }
            pub fn getVersion(_shm: *Shm) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_shm)).getVersion();
            }
            pub fn getUserData(_shm: *Shm) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_shm)).getUserData();
            }
            pub fn setQueue(_shm: *Shm, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_shm);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// Informs the client about a valid pixel format that
                /// can be used for buffers. Known formats include
                /// argb8888 and xrgb8888.
                format: struct {
                    format: Format,
                },
            };
            pub inline fn setListener(
                _shm: *Shm,
                comptime T: type,
                _listener: *const fn (shm: *Shm, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_shm);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Shm, T).dispatcher, _listener, _mut_data);
            }
            /// Create a new wl_shm_pool object.
            ///
            /// The pool can be used to create shared memory based buffer
            /// objects.  The server will mmap size bytes of the passed file
            /// descriptor, to use as backing memory for the pool.
            pub fn createPool(_shm: *Shm, _fd: i32, _size: i32) !*client.wl.ShmPool {
                const _proxy: *client.wl.Proxy = @ptrCast(_shm);
                var _args = [_]common.Argument{
                    .{ .o = null },
                    .{ .h = _fd },
                    .{ .i = _size },
                };
                return @ptrCast(try _proxy.marshalConstructor(0, &_args, client.wl.ShmPool.interface));
            }
            pub fn destroy(_shm: *Shm) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_shm);
                _proxy.destroy();
            }
        };

        /// The wl_shm_pool object encapsulates a piece of memory shared
        /// between the compositor and client.  Through the wl_shm_pool
        /// object, the client can allocate shared memory wl_buffer objects.
        /// All objects created through the same pool share the same
        /// underlying mapped memory. Reusing the mapped memory avoids the
        /// setup/teardown overhead and is useful when interactively resizing
        /// a surface or for many small buffers.
        pub const ShmPool = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.shm_pool.interface;
            pub fn getId(_shm_pool: *ShmPool) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_shm_pool)).getId();
            }
            pub fn getVersion(_shm_pool: *ShmPool) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_shm_pool)).getVersion();
            }
            pub fn getUserData(_shm_pool: *ShmPool) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_shm_pool)).getUserData();
            }
            pub fn setQueue(_shm_pool: *ShmPool, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_shm_pool);
                _proxy.setQueue(_queue);
            }
            /// Create a wl_buffer object from the pool.
            ///
            /// The buffer is created offset bytes into the pool and has
            /// width and height as specified.  The stride argument specifies
            /// the number of bytes from the beginning of one row to the beginning
            /// of the next.  The format is the pixel format of the buffer and
            /// must be one of those advertised through the wl_shm.format event.
            ///
            /// A buffer will keep a reference to the pool it was created from
            /// so it is valid to destroy the pool immediately after creating
            /// a buffer from it.
            pub fn createBuffer(_shm_pool: *ShmPool, _offset: i32, _width: i32, _height: i32, _stride: i32, _format: common.wl.shm.Format) !*client.wl.Buffer {
                const _proxy: *client.wl.Proxy = @ptrCast(_shm_pool);
                var _args = [_]common.Argument{
                    .{ .o = null },
                    .{ .i = _offset },
                    .{ .i = _width },
                    .{ .i = _height },
                    .{ .i = _stride },
                    .{ .u = switch (@typeInfo(common.wl.shm.Format)) {
                        .@"enum" => @as(u32, @intCast(@intFromEnum(_format))),
                        .@"struct" => @bitCast(_format),
                        else => unreachable,
                    } },
                };
                return @ptrCast(try _proxy.marshalConstructor(0, &_args, client.wl.Buffer.interface));
            }

            /// Destroy the shared memory pool.
            ///
            /// The mmapped memory will be released when all
            /// buffers that have been created from this pool
            /// are gone.
            pub fn destroy(_shm_pool: *ShmPool) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_shm_pool);
                _proxy.marshal(1, null);
                _proxy.destroy();
            }

            /// This request will cause the server to remap the backing memory
            /// for the pool from the file descriptor passed when the pool was
            /// created, but using the new size.  This request can only be
            /// used to make the pool bigger.
            ///
            /// This request only changes the amount of bytes that are mmapped
            /// by the server and does not touch the file corresponding to the
            /// file descriptor passed at creation time. It is the client's
            /// responsibility to ensure that the file is at least as big as
            /// the new pool size.
            pub fn resize(_shm_pool: *ShmPool, _size: i32) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_shm_pool);
                var _args = [_]common.Argument{
                    .{ .i = _size },
                };
                _proxy.marshal(2, &_args);
            }
        };

        /// A seat is a group of keyboards, pointer and touch devices. This
        /// object is published as a global during start up, or when such a
        /// device is hot plugged.  A seat typically has a pointer and
        /// maintains a keyboard focus and a pointer focus.
        pub const Seat = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.seat.interface;
            pub const Capability = common.wl.seat.Capability;
            pub const Error = common.wl.seat.Error;
            pub fn getId(_seat: *Seat) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_seat)).getId();
            }
            pub fn getVersion(_seat: *Seat) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_seat)).getVersion();
            }
            pub fn getUserData(_seat: *Seat) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_seat)).getUserData();
            }
            pub fn setQueue(_seat: *Seat, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_seat);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// This is sent on binding to the seat global or whenever a seat gains
                /// or loses the pointer, keyboard or touch capabilities.
                /// The argument is a capability enum containing the complete set of
                /// capabilities this seat has.
                ///
                /// When the pointer capability is added, a client may create a
                /// wl_pointer object using the wl_seat.get_pointer request. This object
                /// will receive pointer events until the capability is removed in the
                /// future.
                ///
                /// When the pointer capability is removed, a client should destroy the
                /// wl_pointer objects associated with the seat where the capability was
                /// removed, using the wl_pointer.release request. No further pointer
                /// events will be received on these objects.
                ///
                /// In some compositors, if a seat regains the pointer capability and a
                /// client has a previously obtained wl_pointer object of version 4 or
                /// less, that object may start sending pointer events again. This
                /// behavior is considered a misinterpretation of the intended behavior
                /// and must not be relied upon by the client. wl_pointer objects of
                /// version 5 or later must not send events if created before the most
                /// recent event notifying the client of an added pointer capability.
                ///
                /// The above behavior also applies to wl_keyboard and wl_touch with the
                /// keyboard and touch capabilities, respectively.
                capabilities: struct {
                    capabilities: Capability,
                },

                /// In a multi-seat configuration the seat name can be used by clients to
                /// help identify which physical devices the seat represents.
                ///
                /// The seat name is a UTF-8 string with no convention defined for its
                /// contents. Each name is unique among all wl_seat globals. The name is
                /// only guaranteed to be unique for the current compositor instance.
                ///
                /// The same seat names are used for all clients. Thus, the name can be
                /// shared across processes to refer to a specific wl_seat global.
                ///
                /// The name event is sent after binding to the seat global, and should be sent
                /// before announcing capabilities. This event only sent once per seat object,
                /// and the name does not change over the lifetime of the wl_seat global.
                ///
                /// Compositors may re-use the same seat name if the wl_seat global is
                /// destroyed and re-created later.
                name: struct {
                    name: [*:0]const u8,
                },
            };
            pub inline fn setListener(
                _seat: *Seat,
                comptime T: type,
                _listener: *const fn (seat: *Seat, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_seat);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Seat, T).dispatcher, _listener, _mut_data);
            }
            /// The ID provided will be initialized to the wl_pointer interface
            /// for this seat.
            ///
            /// This request only takes effect if the seat has the pointer
            /// capability, or has had the pointer capability in the past.
            /// It is a protocol violation to issue this request on a seat that has
            /// never had the pointer capability. The missing_capability error will
            /// be sent in this case.
            pub fn getPointer(_seat: *Seat) !*client.wl.Pointer {
                const _proxy: *client.wl.Proxy = @ptrCast(_seat);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(0, &_args, client.wl.Pointer.interface));
            }

            /// The ID provided will be initialized to the wl_keyboard interface
            /// for this seat.
            ///
            /// This request only takes effect if the seat has the keyboard
            /// capability, or has had the keyboard capability in the past.
            /// It is a protocol violation to issue this request on a seat that has
            /// never had the keyboard capability. The missing_capability error will
            /// be sent in this case.
            pub fn getKeyboard(_seat: *Seat) !*client.wl.Keyboard {
                const _proxy: *client.wl.Proxy = @ptrCast(_seat);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(1, &_args, client.wl.Keyboard.interface));
            }

            /// The ID provided will be initialized to the wl_touch interface
            /// for this seat.
            ///
            /// This request only takes effect if the seat has the touch
            /// capability, or has had the touch capability in the past.
            /// It is a protocol violation to issue this request on a seat that has
            /// never had the touch capability. The missing_capability error will
            /// be sent in this case.
            pub fn getTouch(_seat: *Seat) !*client.wl.Touch {
                const _proxy: *client.wl.Proxy = @ptrCast(_seat);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(2, &_args, client.wl.Touch.interface));
            }

            /// Using this request a client can tell the server that it is not going to
            /// use the seat object anymore.
            pub fn release(_seat: *Seat) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_seat);
                _proxy.marshal(3, null);
                _proxy.destroy();
            }
            pub fn destroy(_seat: *Seat) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_seat);
                _proxy.destroy();
            }
        };

        /// The wl_pointer interface represents one or more input devices,
        /// such as mice, which control the pointer location and pointer_focus
        /// of a seat.
        ///
        /// The wl_pointer interface generates motion, enter and leave
        /// events for the surfaces that the pointer is located over,
        /// and button and axis events for button presses, button releases
        /// and scrolling.
        pub const Pointer = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.pointer.interface;
            pub const Error = common.wl.pointer.Error;
            pub const ButtonState = common.wl.pointer.ButtonState;
            pub const Axis = common.wl.pointer.Axis;
            pub const AxisSource = common.wl.pointer.AxisSource;
            pub const AxisRelativeDirection = common.wl.pointer.AxisRelativeDirection;
            pub fn getId(_pointer: *Pointer) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_pointer)).getId();
            }
            pub fn getVersion(_pointer: *Pointer) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_pointer)).getVersion();
            }
            pub fn getUserData(_pointer: *Pointer) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_pointer)).getUserData();
            }
            pub fn setQueue(_pointer: *Pointer, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_pointer);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// Notification that this seat's pointer is focused on a certain
                /// surface.
                ///
                /// When a seat's focus enters a surface, the pointer image
                /// is undefined and a client should respond to this event by setting
                /// an appropriate pointer image with the set_cursor request.
                enter: struct {
                    serial: u32,
                    surface: ?*client.wl.Surface,
                    surface_x: common.Fixed,
                    surface_y: common.Fixed,
                },

                /// Notification that this seat's pointer is no longer focused on
                /// a certain surface.
                ///
                /// The leave notification is sent before the enter notification
                /// for the new focus.
                leave: struct {
                    serial: u32,
                    surface: ?*client.wl.Surface,
                },

                /// Notification of pointer location change. The arguments
                /// surface_x and surface_y are the location relative to the
                /// focused surface.
                motion: struct {
                    time: u32,
                    surface_x: common.Fixed,
                    surface_y: common.Fixed,
                },

                /// Mouse button click and release notifications.
                ///
                /// The location of the click is given by the last motion or
                /// enter event.
                /// The time argument is a timestamp with millisecond
                /// granularity, with an undefined base.
                ///
                /// The button is a button code as defined in the Linux kernel's
                /// linux/input-event-codes.h header file, e.g. BTN_LEFT.
                ///
                /// Any 16-bit button code value is reserved for future additions to the
                /// kernel's event code list. All other button codes above 0xFFFF are
                /// currently undefined but may be used in future versions of this
                /// protocol.
                button: struct {
                    serial: u32,
                    time: u32,
                    button: u32,
                    state: ButtonState,
                },

                /// Scroll and other axis notifications.
                ///
                /// For scroll events (vertical and horizontal scroll axes), the
                /// value parameter is the length of a vector along the specified
                /// axis in a coordinate space identical to those of motion events,
                /// representing a relative movement along the specified axis.
                ///
                /// For devices that support movements non-parallel to axes multiple
                /// axis events will be emitted.
                ///
                /// When applicable, for example for touch pads, the server can
                /// choose to emit scroll events where the motion vector is
                /// equivalent to a motion event vector.
                ///
                /// When applicable, a client can transform its content relative to the
                /// scroll distance.
                axis: struct {
                    time: u32,
                    axis: Axis,
                    value: common.Fixed,
                },

                /// Indicates the end of a set of events that logically belong together.
                /// A client is expected to accumulate the data in all events within the
                /// frame before proceeding.
                ///
                /// All wl_pointer events before a wl_pointer.frame event belong
                /// logically together. For example, in a diagonal scroll motion the
                /// compositor will send an optional wl_pointer.axis_source event, two
                /// wl_pointer.axis events (horizontal and vertical) and finally a
                /// wl_pointer.frame event. The client may use this information to
                /// calculate a diagonal vector for scrolling.
                ///
                /// When multiple wl_pointer.axis events occur within the same frame,
                /// the motion vector is the combined motion of all events.
                /// When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
                /// the same frame, this indicates that axis movement in one axis has
                /// stopped but continues in the other axis.
                /// When multiple wl_pointer.axis_stop events occur within the same
                /// frame, this indicates that these axes stopped in the same instance.
                ///
                /// A wl_pointer.frame event is sent for every logical event group,
                /// even if the group only contains a single wl_pointer event.
                /// Specifically, a client may get a sequence: motion, frame, button,
                /// frame, axis, frame, axis_stop, frame.
                ///
                /// The wl_pointer.enter and wl_pointer.leave events are logical events
                /// generated by the compositor and not the hardware. These events are
                /// also grouped by a wl_pointer.frame. When a pointer moves from one
                /// surface to another, a compositor should group the
                /// wl_pointer.leave event within the same wl_pointer.frame.
                /// However, a client must not rely on wl_pointer.leave and
                /// wl_pointer.enter being in the same wl_pointer.frame.
                /// Compositor-specific policies may require the wl_pointer.leave and
                /// wl_pointer.enter event being split across multiple wl_pointer.frame
                /// groups.
                frame: void,
                /// Source information for scroll and other axes.
                ///
                /// This event does not occur on its own. It is sent before a
                /// wl_pointer.frame event and carries the source information for
                /// all events within that frame.
                ///
                /// The source specifies how this event was generated. If the source is
                /// wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
                /// sent when the user lifts the finger off the device.
                ///
                /// If the source is wl_pointer.axis_source.wheel,
                /// wl_pointer.axis_source.wheel_tilt or
                /// wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
                /// or may not be sent. Whether a compositor sends an axis_stop event
                /// for these sources is hardware-specific and implementation-dependent;
                /// clients must not rely on receiving an axis_stop event for these
                /// scroll sources and should treat scroll sequences from these scroll
                /// sources as unterminated by default.
                ///
                /// This event is optional. If the source is unknown for a particular
                /// axis event sequence, no event is sent.
                /// Only one wl_pointer.axis_source event is permitted per frame.
                ///
                /// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
                /// not guaranteed.
                axis_source: struct {
                    axis_source: AxisSource,
                },

                /// Stop notification for scroll and other axes.
                ///
                /// For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
                /// is sent to notify a client that the axis sequence has terminated.
                /// This enables the client to implement kinetic scrolling.
                /// See the wl_pointer.axis_source documentation for information on when
                /// this event may be generated.
                ///
                /// Any wl_pointer.axis events with the same axis_source after this
                /// event should be considered as the start of a new axis motion.
                ///
                /// The timestamp is to be interpreted identical to the timestamp in the
                /// wl_pointer.axis event. The timestamp value may be the same as a
                /// preceding wl_pointer.axis event.
                axis_stop: struct {
                    time: u32,
                    axis: Axis,
                },

                /// Discrete step information for scroll and other axes.
                ///
                /// This event carries the axis value of the wl_pointer.axis event in
                /// discrete steps (e.g. mouse wheel clicks).
                ///
                /// This event is deprecated with wl_pointer version 8 - this event is not
                /// sent to clients supporting version 8 or later.
                ///
                /// This event does not occur on its own, it is coupled with a
                /// wl_pointer.axis event that represents this axis value on a
                /// continuous scale. The protocol guarantees that each axis_discrete
                /// event is always followed by exactly one axis event with the same
                /// axis number within the same wl_pointer.frame. Note that the protocol
                /// allows for other events to occur between the axis_discrete and
                /// its coupled axis event, including other axis_discrete or axis
                /// events. A wl_pointer.frame must not contain more than one axis_discrete
                /// event per axis type.
                ///
                /// This event is optional; continuous scrolling devices
                /// like two-finger scrolling on touchpads do not have discrete
                /// steps and do not generate this event.
                ///
                /// The discrete value carries the directional information. e.g. a value
                /// of -2 is two steps towards the negative direction of this axis.
                ///
                /// The axis number is identical to the axis number in the associated
                /// axis event.
                ///
                /// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
                /// not guaranteed.
                axis_discrete: struct {
                    axis: Axis,
                    discrete: i32,
                },
            };
            pub inline fn setListener(
                _pointer: *Pointer,
                comptime T: type,
                _listener: *const fn (pointer: *Pointer, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_pointer);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Pointer, T).dispatcher, _listener, _mut_data);
            }
            /// Set the pointer surface, i.e., the surface that contains the
            /// pointer image (cursor). This request gives the surface the role
            /// of a cursor. If the surface already has another role, it raises
            /// a protocol error.
            ///
            /// The cursor actually changes only if the pointer
            /// focus for this device is one of the requesting client's surfaces
            /// or the surface parameter is the current pointer surface. If
            /// there was a previous surface set with this request it is
            /// replaced. If surface is NULL, the pointer image is hidden.
            ///
            /// The parameters hotspot_x and hotspot_y define the position of
            /// the pointer surface relative to the pointer location. Its
            /// top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
            /// where (x, y) are the coordinates of the pointer location, in
            /// surface-local coordinates.
            ///
            /// On wl_surface.offset requests to the pointer surface, hotspot_x
            /// and hotspot_y are decremented by the x and y parameters
            /// passed to the request. The offset must be applied by
            /// wl_surface.commit as usual.
            ///
            /// The hotspot can also be updated by passing the currently set
            /// pointer surface to this request with new values for hotspot_x
            /// and hotspot_y.
            ///
            /// The input region is ignored for wl_surfaces with the role of
            /// a cursor. When the use as a cursor ends, the wl_surface is
            /// unmapped.
            ///
            /// The serial parameter must match the latest wl_pointer.enter
            /// serial number sent to the client. Otherwise the request will be
            /// ignored.
            pub fn setCursor(_pointer: *Pointer, _serial: u32, _surface: ?*client.wl.Surface, _hotspot_x: i32, _hotspot_y: i32) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_pointer);
                var _args = [_]common.Argument{
                    .{ .u = _serial },
                    .{ .o = @ptrCast(_surface) },
                    .{ .i = _hotspot_x },
                    .{ .i = _hotspot_y },
                };
                _proxy.marshal(0, &_args);
            }

            /// Using this request a client can tell the server that it is not going to
            /// use the pointer object anymore.
            ///
            /// This request destroys the pointer proxy object, so clients must not call
            /// wl_pointer_destroy() after using this request.
            pub fn release(_pointer: *Pointer) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_pointer);
                _proxy.marshal(1, null);
                _proxy.destroy();
            }
            pub fn destroy(_pointer: *Pointer) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_pointer);
                _proxy.destroy();
            }
        };

        /// The wl_keyboard interface represents one or more keyboards
        /// associated with a seat.
        ///
        /// Each wl_keyboard has the following logical state:
        ///
        /// - an active surface (possibly null),
        /// - the keys currently logically down,
        /// - the active modifiers,
        /// - the active group.
        ///
        /// By default, the active surface is null, the keys currently logically down
        /// are empty, the active modifiers and the active group are 0.
        pub const Keyboard = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.keyboard.interface;
            pub const KeymapFormat = common.wl.keyboard.KeymapFormat;
            pub const KeyState = common.wl.keyboard.KeyState;
            pub fn getId(_keyboard: *Keyboard) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_keyboard)).getId();
            }
            pub fn getVersion(_keyboard: *Keyboard) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_keyboard)).getVersion();
            }
            pub fn getUserData(_keyboard: *Keyboard) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_keyboard)).getUserData();
            }
            pub fn setQueue(_keyboard: *Keyboard, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_keyboard);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// This event provides a file descriptor to the client which can be
                /// memory-mapped in read-only mode to provide a keyboard mapping
                /// description.
                ///
                /// From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
                /// the recipient, as MAP_SHARED may fail.
                keymap: struct {
                    format: KeymapFormat,
                    fd: i32,
                    size: u32,
                },

                /// Notification that this seat's keyboard focus is on a certain
                /// surface.
                ///
                /// The compositor must send the wl_keyboard.modifiers event after this
                /// event.
                ///
                /// In the wl_keyboard logical state, this event sets the active surface to
                /// the surface argument and the keys currently logically down to the keys
                /// in the keys argument. The compositor must not send this event if the
                /// wl_keyboard already had an active surface immediately before this event.
                ///
                /// Clients should not use the list of pressed keys to emulate key-press
                /// events. The order of keys in the list is unspecified.
                enter: struct {
                    serial: u32,
                    surface: ?*client.wl.Surface,
                    keys: *common.Array,
                },

                /// Notification that this seat's keyboard focus is no longer on
                /// a certain surface.
                ///
                /// The leave notification is sent before the enter notification
                /// for the new focus.
                ///
                /// In the wl_keyboard logical state, this event resets all values to their
                /// defaults. The compositor must not send this event if the active surface
                /// of the wl_keyboard was not equal to the surface argument immediately
                /// before this event.
                leave: struct {
                    serial: u32,
                    surface: ?*client.wl.Surface,
                },

                /// A key was pressed or released.
                /// The time argument is a timestamp with millisecond
                /// granularity, with an undefined base.
                ///
                /// The key is a platform-specific key code that can be interpreted
                /// by feeding it to the keyboard mapping (see the keymap event).
                ///
                /// If this event produces a change in modifiers, then the resulting
                /// wl_keyboard.modifiers event must be sent after this event.
                ///
                /// In the wl_keyboard logical state, this event adds the key to the keys
                /// currently logically down (if the state argument is pressed) or removes
                /// the key from the keys currently logically down (if the state argument is
                /// released). The compositor must not send this event if the wl_keyboard
                /// did not have an active surface immediately before this event. The
                /// compositor must not send this event if state is pressed (resp. released)
                /// and the key was already logically down (resp. was not logically down)
                /// immediately before this event.
                ///
                /// Since version 10, compositors may send key events with the "repeated"
                /// key state when a wl_keyboard.repeat_info event with a rate argument of
                /// 0 has been received. This allows the compositor to take over the
                /// responsibility of key repetition.
                key: struct {
                    serial: u32,
                    time: u32,
                    key: u32,
                    state: KeyState,
                },

                /// Notifies clients that the modifier and/or group state has
                /// changed, and it should update its local state.
                ///
                /// The compositor may send this event without a surface of the client
                /// having keyboard focus, for example to tie modifier information to
                /// pointer focus instead. If a modifier event with pressed modifiers is sent
                /// without a prior enter event, the client can assume the modifier state is
                /// valid until it receives the next wl_keyboard.modifiers event. In order to
                /// reset the modifier state again, the compositor can send a
                /// wl_keyboard.modifiers event with no pressed modifiers.
                ///
                /// In the wl_keyboard logical state, this event updates the modifiers and
                /// group.
                modifiers: struct {
                    serial: u32,
                    mods_depressed: u32,
                    mods_latched: u32,
                    mods_locked: u32,
                    group: u32,
                },

                /// Informs the client about the keyboard's repeat rate and delay.
                ///
                /// This event is sent as soon as the wl_keyboard object has been created,
                /// and is guaranteed to be received by the client before any key press
                /// event.
                ///
                /// Negative values for either rate or delay are illegal. A rate of zero
                /// will disable any repeating (regardless of the value of delay).
                ///
                /// This event can be sent later on as well with a new value if necessary,
                /// so clients should continue listening for the event past the creation
                /// of wl_keyboard.
                repeat_info: struct {
                    rate: i32,
                    delay: i32,
                },
            };
            pub inline fn setListener(
                _keyboard: *Keyboard,
                comptime T: type,
                _listener: *const fn (keyboard: *Keyboard, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_keyboard);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Keyboard, T).dispatcher, _listener, _mut_data);
            }
            pub fn release(_keyboard: *Keyboard) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_keyboard);
                _proxy.marshal(0, null);
                _proxy.destroy();
            }
            pub fn destroy(_keyboard: *Keyboard) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_keyboard);
                _proxy.destroy();
            }
        };

        /// The wl_touch interface represents a touchscreen
        /// associated with a seat.
        ///
        /// Touch interactions can consist of one or more contacts.
        /// For each contact, a series of events is generated, starting
        /// with a down event, followed by zero or more motion events,
        /// and ending with an up event. Events relating to the same
        /// contact point can be identified by the ID of the sequence.
        pub const Touch = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.touch.interface;
            pub fn getId(_touch: *Touch) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_touch)).getId();
            }
            pub fn getVersion(_touch: *Touch) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_touch)).getVersion();
            }
            pub fn getUserData(_touch: *Touch) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_touch)).getUserData();
            }
            pub fn setQueue(_touch: *Touch, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_touch);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// A new touch point has appeared on the surface. This touch point is
                /// assigned a unique ID. Future events from this touch point reference
                /// this ID. The ID ceases to be valid after a touch up event and may be
                /// reused in the future.
                down: struct {
                    serial: u32,
                    time: u32,
                    surface: ?*client.wl.Surface,
                    id: i32,
                    x: common.Fixed,
                    y: common.Fixed,
                },

                /// The touch point has disappeared. No further events will be sent for
                /// this touch point and the touch point's ID is released and may be
                /// reused in a future touch down event.
                up: struct {
                    serial: u32,
                    time: u32,
                    id: i32,
                },

                /// A touch point has changed coordinates.
                motion: struct {
                    time: u32,
                    id: i32,
                    x: common.Fixed,
                    y: common.Fixed,
                },

                /// Indicates the end of a set of events that logically belong together.
                /// A client is expected to accumulate the data in all events within the
                /// frame before proceeding.
                ///
                /// A wl_touch.frame terminates at least one event but otherwise no
                /// guarantee is provided about the set of events within a frame. A client
                /// must assume that any state not updated in a frame is unchanged from the
                /// previously known state.
                frame: void,
                /// Sent if the compositor decides the touch stream is a global
                /// gesture. No further events are sent to the clients from that
                /// particular gesture. Touch cancellation applies to all touch points
                /// currently active on this client's surface. The client is
                /// responsible for finalizing the touch points, future touch points on
                /// this surface may reuse the touch point ID.
                ///
                /// No frame event is required after the cancel event.
                cancel: void,
            };
            pub inline fn setListener(
                _touch: *Touch,
                comptime T: type,
                _listener: *const fn (touch: *Touch, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_touch);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Touch, T).dispatcher, _listener, _mut_data);
            }
            pub fn release(_touch: *Touch) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_touch);
                _proxy.marshal(0, null);
                _proxy.destroy();
            }
            pub fn destroy(_touch: *Touch) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_touch);
                _proxy.destroy();
            }
        };

        /// An output describes part of the compositor geometry.  The
        /// compositor works in the 'compositor coordinate system' and an
        /// output corresponds to a rectangular area in that space that is
        /// actually visible.  This typically corresponds to a monitor that
        /// displays part of the compositor space.  This object is published
        /// as global during start up, or when a monitor is hotplugged.
        pub const Output = opaque {
            pub const generated_version = 4;
            pub const interface = &common.wl.output.interface;
            pub const Subpixel = common.wl.output.Subpixel;
            pub const Transform = common.wl.output.Transform;
            pub const Mode = common.wl.output.Mode;
            pub fn getId(_output: *Output) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_output)).getId();
            }
            pub fn getVersion(_output: *Output) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_output)).getVersion();
            }
            pub fn getUserData(_output: *Output) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_output)).getUserData();
            }
            pub fn setQueue(_output: *Output, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_output);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// The geometry event describes geometric properties of the output.
                /// The event is sent when binding to the output object and whenever
                /// any of the properties change.
                ///
                /// The physical size can be set to zero if it doesn't make sense for this
                /// output (e.g. for projectors or virtual outputs).
                ///
                /// The geometry event will be followed by a done event (starting from
                /// version 2).
                ///
                /// Clients should use wl_surface.preferred_buffer_transform instead of the
                /// transform advertised by this event to find the preferred buffer
                /// transform to use for a surface.
                ///
                /// Note: wl_output only advertises partial information about the output
                /// position and identification. Some compositors, for instance those not
                /// implementing a desktop-style output layout or those exposing virtual
                /// outputs, might fake this information. Instead of using x and y, clients
                /// should use xdg_output.logical_position. Instead of using make and model,
                /// clients should use name and description.
                geometry: struct {
                    x: i32,
                    y: i32,
                    physical_width: i32,
                    physical_height: i32,
                    subpixel: Subpixel,
                    make: [*:0]const u8,
                    model: [*:0]const u8,
                    transform: Transform,
                },

                /// The mode event describes an available mode for the output.
                ///
                /// The event is sent when binding to the output object and there
                /// will always be one mode, the current mode.  The event is sent
                /// again if an output changes mode, for the mode that is now
                /// current.  In other words, the current mode is always the last
                /// mode that was received with the current flag set.
                ///
                /// Non-current modes are deprecated. A compositor can decide to only
                /// advertise the current mode and never send other modes. Clients
                /// should not rely on non-current modes.
                ///
                /// The size of a mode is given in physical hardware units of
                /// the output device. This is not necessarily the same as
                /// the output size in the global compositor space. For instance,
                /// the output may be scaled, as described in wl_output.scale,
                /// or transformed, as described in wl_output.transform. Clients
                /// willing to retrieve the output size in the global compositor
                /// space should use xdg_output.logical_size instead.
                ///
                /// The vertical refresh rate can be set to zero if it doesn't make
                /// sense for this output (e.g. for virtual outputs).
                ///
                /// The mode event will be followed by a done event (starting from
                /// version 2).
                ///
                /// Clients should not use the refresh rate to schedule frames. Instead,
                /// they should use the wl_surface.frame event or the presentation-time
                /// protocol.
                ///
                /// Note: this information is not always meaningful for all outputs. Some
                /// compositors, such as those exposing virtual outputs, might fake the
                /// refresh rate or the size.
                mode: struct {
                    flags: Mode,
                    width: i32,
                    height: i32,
                    refresh: i32,
                },

                /// This event is sent after all other properties have been
                /// sent after binding to the output object and after any
                /// other property changes done after that. This allows
                /// changes to the output properties to be seen as
                /// atomic, even if they happen via multiple events.
                done: void,
                /// This event contains scaling geometry information
                /// that is not in the geometry event. It may be sent after
                /// binding the output object or if the output scale changes
                /// later. The compositor will emit a non-zero, positive
                /// value for scale. If it is not sent, the client should
                /// assume a scale of 1.
                ///
                /// A scale larger than 1 means that the compositor will
                /// automatically scale surface buffers by this amount
                /// when rendering. This is used for very high resolution
                /// displays where applications rendering at the native
                /// resolution would be too small to be legible.
                ///
                /// Clients should use wl_surface.preferred_buffer_scale
                /// instead of this event to find the preferred buffer
                /// scale to use for a surface.
                ///
                /// The scale event will be followed by a done event.
                scale: struct {
                    factor: i32,
                },

                /// Many compositors will assign user-friendly names to their outputs, show
                /// them to the user, allow the user to refer to an output, etc. The client
                /// may wish to know this name as well to offer the user similar behaviors.
                ///
                /// The name is a UTF-8 string with no convention defined for its contents.
                /// Each name is unique among all wl_output globals. The name is only
                /// guaranteed to be unique for the compositor instance.
                ///
                /// The same output name is used for all clients for a given wl_output
                /// global. Thus, the name can be shared across processes to refer to a
                /// specific wl_output global.
                ///
                /// The name is not guaranteed to be persistent across sessions, thus cannot
                /// be used to reliably identify an output in e.g. configuration files.
                ///
                /// Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
                /// not assume that the name is a reflection of an underlying DRM connector,
                /// X11 connection, etc.
                ///
                /// The name event is sent after binding the output object. This event is
                /// only sent once per output object, and the name does not change over the
                /// lifetime of the wl_output global.
                ///
                /// Compositors may re-use the same output name if the wl_output global is
                /// destroyed and re-created later. Compositors should avoid re-using the
                /// same name if possible.
                ///
                /// The name event will be followed by a done event.
                name: struct {
                    name: [*:0]const u8,
                },

                /// Many compositors can produce human-readable descriptions of their
                /// outputs. The client may wish to know this description as well, e.g. for
                /// output selection purposes.
                ///
                /// The description is a UTF-8 string with no convention defined for its
                /// contents. The description is not guaranteed to be unique among all
                /// wl_output globals. Examples might include 'Foocorp 11" Display' or
                /// 'Virtual X11 output via :1'.
                ///
                /// The description event is sent after binding the output object and
                /// whenever the description changes. The description is optional, and may
                /// not be sent at all.
                ///
                /// The description event will be followed by a done event.
                description: struct {
                    description: [*:0]const u8,
                },
            };
            pub inline fn setListener(
                _output: *Output,
                comptime T: type,
                _listener: *const fn (output: *Output, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_output);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Output, T).dispatcher, _listener, _mut_data);
            }
            /// Using this request a client can tell the server that it is not going to
            /// use the output object anymore.
            pub fn release(_output: *Output) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_output);
                _proxy.marshal(0, null);
                _proxy.destroy();
            }
            pub fn destroy(_output: *Output) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_output);
                _proxy.destroy();
            }
        };
    };
};

pub const server = struct {
    pub const wl = struct {
        pub const Object = common.Object;
        pub const Message = common.Message;
        pub const Interface = common.Interface;
        pub const list = common.list;
        pub const Array = common.Array;
        pub const Fixed = common.Fixed;
        pub const Argument = common.Argument;

        /// This is wayland-server's wl_display. It has been renamed as zig-wayland has
        /// decided to hide wl_resources with opaque pointers in the same way that
        /// wayland-client does with wl_proxys. This of course creates a name conflict.
        pub const Server = opaque {
            extern fn wl_display_create() ?*Server;
            pub fn create() !*Server {
                return wl_display_create() orelse error.ServerCreateFailed;
            }

            extern fn wl_display_destroy(server: *Server) void;
            pub const destroy = wl_display_destroy;

            extern fn wl_display_get_event_loop(server: *Server) *EventLoop;
            pub const getEventLoop = wl_display_get_event_loop;

            extern fn wl_display_add_socket(server: *Server, name: [*:0]const u8) c_int;
            pub fn addSocket(_server: *Server, name: [*:0]const u8) !void {
                if (wl_display_add_socket(_server, name) == -1)
                    return error.AddSocketFailed;
            }

            // wayland-client will connect to wayland-0 even if WAYLAND_DISPLAY is
            // unset due to an unfortunate piece of code that was not removed before
            // the library was stabilized. Because of this, it is a good idea to never
            // call the socket wayland-0. So, instead of binding to wayland-server's
            // wl_display_add_socket_auto we implement a version which skips wayland-0.
            pub fn addSocketAuto(_server: *Server, buf: *[11]u8) ![:0]const u8 {
                // Don't use wayland-0
                var i: u32 = 1;
                while (i <= 32) : (i += 1) {
                    const name = std.fmt.bufPrintZ(buf, "wayland-{}", .{i}) catch unreachable;
                    _server.addSocket(name.ptr) catch continue;
                    return name;
                }
                return error.AddSocketFailed;
            }

            extern fn wl_display_add_socket_fd(_server: *Server, sock_fd: c_int) c_int;
            pub fn addSocketFd(_server: *Server, sock_fd: c_int) !void {
                if (wl_display_add_socket_fd(_server, sock_fd) == -1)
                    return error.AddSocketFailed;
            }

            extern fn wl_display_terminate(_server: *Server) void;
            pub const terminate = wl_display_terminate;

            extern fn wl_display_run(_server: *Server) void;
            pub const run = wl_display_run;

            extern fn wl_display_flush_clients(_server: *Server) void;
            pub const flushClients = wl_display_flush_clients;

            extern fn wl_display_destroy_clients(_server: *Server) void;
            pub const destroyClients = wl_display_destroy_clients;

            extern fn wl_display_get_serial(_server: *Server) u32;
            pub const getSerial = wl_display_get_serial;

            extern fn wl_display_next_serial(_server: *Server) u32;
            pub const nextSerial = wl_display_next_serial;

            extern fn wl_display_add_destroy_listener(_server: *Server, listener: *Listener(*Server)) void;
            pub const addDestroyListener = wl_display_add_destroy_listener;

            extern fn wl_display_add_client_created_listener(_server: *Server, listener: *Listener(*Client)) void;
            pub const addClientCreatedListener = wl_display_add_client_created_listener;

            // Doesn't really make sense with our Listener API as we would need to
            // pass a pointer to the wrapper function
            //extern fn wl_display_get_destroy_listener(_server: *Server, notify: @TypeOf(Listener(*Server).notify)) ?*Listener(*Server);

            extern fn wl_display_set_global_filter(
                _server: *Server,
                filter: *const fn (_client: *const Client, global: *const Global, data: ?*anyopaque) callconv(.c) bool,
                data: ?*anyopaque,
            ) void;
            pub inline fn setGlobalFilter(
                _server: *Server,
                comptime T: type,
                comptime filter: fn (_client: *const Client, global: *const Global, data: T) bool,
                data: T,
            ) void {
                wl_display_set_global_filter(
                    _server,
                    struct {
                        fn _wrapper(_client: *const Client, _global: *const Global, _data: ?*anyopaque) callconv(.c) bool {
                            return filter(_client, _global, @ptrCast(@alignCast(_data)));
                        }
                    }._wrapper,
                    data,
                );
            }

            extern fn wl_display_get_client_list(_server: *Server) *list.Head(Client, null);
            pub const getClientList = wl_display_get_client_list;

            extern fn wl_display_init_shm(_server: *Server) c_int;
            pub fn initShm(_server: *Server) !void {
                if (wl_display_init_shm(_server) == -1) return error.OutOfMemory;
            }

            extern fn wl_display_add_shm_format(_server: *Server, format: u32) ?*u32;
            pub fn addShmFormat(_server: *Server, format: u32) !*u32 {
                return wl_display_add_shm_format(_server, format) orelse error.OutOfMemory;
            }

            extern fn wl_display_add_protocol_logger(
                _server: *Server,
                func: *const fn (data: ?*anyopaque, direction: ProtocolLogger.Type, message: *const ProtocolLogger.LogMessage) callconv(.c) void,
                data: ?*anyopaque,
            ) void;
            pub inline fn addProtocolLogger(
                _server: *Server,
                comptime T: type,
                comptime func: fn (data: T, direction: ProtocolLogger.Type, message: *const ProtocolLogger.LogMessage) void,
                data: T,
            ) void {
                wl_display_add_protocol_logger(
                    _server,
                    struct {
                        fn _wrapper(_data: ?*anyopaque, _direction: ProtocolLogger.Type, _message: *const ProtocolLogger.LogMessage) callconv(.c) void {
                            func(@ptrCast(@alignCast(_data)), _direction, _message);
                        }
                    }._wrapper,
                    data,
                );
            }
        };

        pub const Client = opaque {
            extern fn wl_client_create(_server: *Server, fd: c_int) ?*Client;
            pub const create = wl_client_create;

            extern fn wl_client_destroy(_client: *Client) void;
            pub const destroy = wl_client_destroy;

            extern fn wl_client_flush(_client: *Client) void;
            pub const flush = wl_client_flush;

            extern fn wl_client_get_link(_client: *Client) *list.Link;
            pub const getLink = wl_client_get_link;

            extern fn wl_client_from_link(link: *list.Link) *Client;
            pub const fromLink = wl_client_from_link;

            const Credentials = struct {
                pid: posix.pid_t,
                gid: posix.gid_t,
                uid: posix.uid_t,
            };
            extern fn wl_client_get_credentials(_client: *Client, pid: *posix.pid_t, uid: *posix.uid_t, gid: *posix.gid_t) void;
            pub fn getCredentials(_client: *Client) Credentials {
                var credentials: Credentials = undefined;
                wl_client_get_credentials(_client, &credentials.pid, &credentials.uid, &credentials.gid);
                return credentials;
            }

            extern fn wl_client_add_destroy_listener(_client: *Client, listener: *Listener(*Client)) void;
            pub const addDestroyListener = wl_client_add_destroy_listener;

            // Doesn't really make sense with our Listener API as we would need to
            // pass a pointer to the wrapper function
            //extern fn wl_client_get_destroy_listener(_client: *Client, notify: @TypeOf(Listener(*Client).notify)) ?*Listener(*Client);

            extern fn wl_client_get_object(_client: *Client, id: u32) ?*Resource;
            pub const getObject = wl_client_get_object;

            extern fn wl_client_post_no_memory(_client: *Client) void;
            pub const postNoMemory = wl_client_post_no_memory;

            extern fn wl_client_post_implementation_error(_client: *Client, msg: [*:0]const u8, ...) void;
            pub const postImplementationError = wl_client_post_implementation_error;

            extern fn wl_client_add_resource_created_listener(_client: *Client, listener: *Listener(*Resource)) void;
            pub const addResourceCreatedListener = wl_client_add_resource_created_listener;

            const IteratorResult = enum(c_int) { stop, cont };
            extern fn wl_client_for_each_resource(
                _client: *Client,
                iterator: *const fn (resource: *Resource, data: ?*anyopaque) callconv(.c) IteratorResult,
                data: ?*anyopaque,
            ) void;
            pub inline fn forEachResource(
                _client: *Client,
                comptime T: type,
                comptime iterator: fn (resource: *Resource, data: T) IteratorResult,
                data: T,
            ) void {
                wl_client_for_each_resource(
                    _client,
                    struct {
                        fn _wrapper(_resource: *Resource, _data: ?*anyopaque) callconv(.c) IteratorResult {
                            return iterator(_resource, @ptrCast(@alignCast(_data)));
                        }
                    }._wrapper,
                    data,
                );
            }

            extern fn wl_client_get_fd(_client: *Client) c_int;
            pub const getFd = wl_client_get_fd;

            extern fn wl_client_get_display(_client: *Client) *Server;
            pub const getDisplay = wl_client_get_display;
        };

        pub const Global = opaque {
            extern fn wl_global_create(
                _server: *Server,
                interface: *const Interface,
                version: c_int,
                data: ?*anyopaque,
                bind: *const fn (_client: *Client, data: ?*anyopaque, version: u32, id: u32) callconv(.c) void,
            ) ?*Global;
            pub inline fn create(
                _server: *Server,
                comptime T: type,
                version: u32,
                comptime DataT: type,
                data: DataT,
                comptime bind: fn (_client: *Client, data: DataT, version: u32, id: u32) void,
            ) error{GlobalCreateFailed}!*Global {
                return wl_global_create(
                    _server,
                    T.interface,
                    @as(c_int, @intCast(version)),
                    data,
                    struct {
                        fn _wrapper(_client: *Client, _data: ?*anyopaque, _version: u32, _id: u32) callconv(.c) void {
                            bind(_client, @ptrCast(@alignCast(_data)), _version, _id);
                        }
                    }._wrapper,
                ) orelse error.GlobalCreateFailed;
            }

            extern fn wl_global_remove(global: *Global) void;
            pub const remove = wl_global_remove;

            extern fn wl_global_destroy(global: *Global) void;
            pub const destroy = wl_global_destroy;

            extern fn wl_global_get_interface(global: *const Global) *const Interface;
            pub const getInterface = wl_global_get_interface;

            extern fn wl_global_get_name(global: *const Global, _client: *const Client) u32;
            pub const getName = wl_global_get_name;

            extern fn wl_global_get_user_data(global: *const Global) ?*anyopaque;
            pub const getUserData = wl_global_get_user_data;
        };

        pub const Resource = opaque {
            extern fn wl_resource_create(_client: *Client, interface: *const Interface, version: c_int, id: u32) ?*Resource;
            pub inline fn create(_client: *Client, comptime T: type, version: u32, id: u32) error{ResourceCreateFailed}!*Resource {
                // This is only a c_int because of legacy libwayland reasons. Negative versions are invalid.
                // Version is a u32 on the wire and for wl_global, wl_proxy, etc.
                return wl_resource_create(_client, T.interface, @as(c_int, @intCast(version)), id) orelse error.ResourceCreateFailed;
            }

            extern fn wl_resource_destroy(resource: *Resource) void;
            pub const destroy = wl_resource_destroy;

            extern fn wl_resource_post_event_array(resource: *Resource, opcode: u32, args: ?[*]Argument) void;
            pub const postEvent = wl_resource_post_event_array;

            extern fn wl_resource_queue_event_array(resource: *Resource, opcode: u32, args: ?[*]Argument) void;
            pub const queueEvent = wl_resource_queue_event_array;

            extern fn wl_resource_post_error(resource: *Resource, code: u32, message: [*:0]const u8, ...) void;
            pub const postError = wl_resource_post_error;

            extern fn wl_resource_post_no_memory(resource: *Resource) void;
            pub const postNoMemory = wl_resource_post_no_memory;

            const DispatcherFn = fn (
                implementation: ?*const anyopaque,
                resource: *Resource,
                opcode: u32,
                message: *const Message,
                args: [*]Argument,
            ) callconv(.c) c_int;
            pub const DestroyFn = fn (resource: *Resource) callconv(.c) void;
            extern fn wl_resource_set_dispatcher(
                resource: *Resource,
                dispatcher: ?*const DispatcherFn,
                implementation: ?*const anyopaque,
                data: ?*anyopaque,
                destroy_fn: ?*const DestroyFn,
            ) void;
            pub fn setDispatcher(
                resource: *Resource,
                dispatcher: ?*const DispatcherFn,
                implementation: ?*const anyopaque,
                data: ?*anyopaque,
                destroy_fn: ?*const DestroyFn,
            ) void {
                wl_resource_set_dispatcher(resource, dispatcher, implementation, data, destroy_fn);
            }

            extern fn wl_resource_get_user_data(resource: *Resource) ?*anyopaque;
            pub const getUserData = wl_resource_get_user_data;

            extern fn wl_resource_get_id(resource: *Resource) u32;
            pub const getId = wl_resource_get_id;

            extern fn wl_resource_get_link(resource: *Resource) *list.Link;
            pub const getLink = wl_resource_get_link;

            extern fn wl_resource_from_link(link: *list.Link) *Resource;
            pub const fromLink = wl_resource_from_link;

            extern fn wl_resource_find_for_client(list: *list.Head(Resource, null), _client: *Client) ?*Resource;
            pub const findForClient = wl_resource_find_for_client;

            extern fn wl_resource_get_client(resource: *Resource) *Client;
            pub const getClient = wl_resource_get_client;

            extern fn wl_resource_get_version(resource: *Resource) c_int;
            pub fn getVersion(resource: *Resource) u32 {
                // The fact that wl_resource.version is a int in libwayland is
                // a mistake. Negative versions are impossible and u32 is used
                // everywhere else in libwayland
                return @as(u32, @intCast(wl_resource_get_version(resource)));
            }

            // TOOD: unsure if this should be bound
            extern fn wl_resource_set_destructor(resource: *Resource, destroy: DestroyFn) void;

            extern fn wl_resource_get_class(resource: *Resource) [*:0]const u8;
            pub const getClass = wl_resource_get_class;

            extern fn wl_resource_add_destroy_listener(resource: *Resource, listener: *Listener(*Resource)) void;
            pub const addDestroyListener = wl_resource_add_destroy_listener;

            // Doesn't really make sense with our Listener API as we would need to
            // pass a pointer to the wrapper function
            //extern fn wl_resource_get_destroy_listener(resource: *Resource, notify: @TypeOf(Listener(*Resource).notify)) ?*Listener(*Resource);
        };

        pub const ProtocolLogger = opaque {
            pub const Type = enum(c_int) {
                request,
                event,
            };

            pub const LogMessage = extern struct {
                resource: *Resource,
                message_opcode: c_int,
                message: *Message,
                arguments_count: c_int,
                arguments: ?[*]Argument,
            };

            extern fn wl_protocol_logger_destroy(logger: *ProtocolLogger) void;
            pub const destroy = wl_protocol_logger_destroy;
        };

        pub fn Listener(comptime T: type) type {
            return extern struct {
                const Self = @This();

                pub const NotifyFn = if (T == void)
                    fn (listener: *Self) void
                else
                    fn (listener: *Self, data: T) void;

                link: list.Link,
                notify: *const fn (listener: *Self, data: ?*anyopaque) callconv(.c) void,

                pub fn init(comptime notify: NotifyFn) Self {
                    var self: Self = undefined;
                    self.setNotify(notify);
                    return self;
                }

                pub fn setNotify(self: *Self, comptime notify: NotifyFn) void {
                    self.notify = if (T == void)
                        struct {
                            fn wrapper(listener: *Self, _: ?*anyopaque) callconv(.c) void {
                                @call(.always_inline, notify, .{listener});
                            }
                        }.wrapper
                    else
                        struct {
                            fn wrapper(listener: *Self, data: ?*anyopaque) callconv(.c) void {
                                @call(.always_inline, notify, .{ listener, @as(T, @ptrFromInt(@intFromPtr(data))) });
                            }
                        }.wrapper;
                }
            };
        }

        pub fn Signal(comptime T: type) type {
            return extern struct {
                const Self = @This();

                listener_list: list.Head(Listener(T), .link),

                pub fn init(signal: *Self) void {
                    signal.listener_list.init();
                }

                pub fn add(signal: *Self, listener: *Listener(T)) void {
                    signal.listener_list.append(listener);
                }

                pub fn get(signal: *Self, notify: @TypeOf(Listener(T).notify)) ?*Listener(T) {
                    var it = signal.listener_list.iterator(.forward);
                    return while (it.next()) |listener| {
                        if (listener.notify == notify) break listener;
                    } else null;
                }

                pub const emit = if (T == void)
                    struct {
                        pub inline fn emit(signal: *Self) void {
                            emitInner(signal, null);
                        }
                    }.emit
                else
                    struct {
                        pub inline fn emit(signal: *Self, data: T) void {
                            emitInner(signal, data);
                        }
                    }.emit;

                /// This is similar to wlroots' wlr_signal_emit_safe. It handles
                /// removal of any element in the list during iteration and stops at
                /// whatever the last element was when iteration started.
                fn emitInner(signal: *Self, data: ?*anyopaque) void {
                    var cursor: Listener(T) = undefined;
                    signal.listener_list.prepend(&cursor);

                    var end: Listener(T) = undefined;
                    signal.listener_list.append(&end);

                    while (cursor.link.next != &end.link) {
                        const pos = cursor.link.next.?;
                        const listener: *Listener(T) = @fieldParentPtr("link", pos);

                        cursor.link.remove();
                        pos.insert(&cursor.link);

                        listener.notify(listener, data);
                    }

                    cursor.link.remove();
                    end.link.remove();
                }
            };
        }

        pub const EventMask = packed struct(u32) {
            readable: bool = false,
            writable: bool = false,
            hangup: bool = false,
            @"error": bool = false,

            _: u28 = 0,
        };

        pub const EventLoop = opaque {
            extern fn wl_event_loop_create() ?*EventLoop;
            pub fn create() !*EventLoop {
                return wl_event_loop_create() orelse error.EventLoopCreateFailed;
            }

            extern fn wl_event_loop_destroy(loop: *EventLoop) void;
            pub const destroy = wl_event_loop_destroy;

            extern fn wl_event_loop_add_fd(
                loop: *EventLoop,
                fd: c_int,
                mask: u32,
                func: *const fn (fd: c_int, mask: u32, data: ?*anyopaque) callconv(.c) c_int,
                data: ?*anyopaque,
            ) ?*EventSource;
            pub inline fn addFd(
                loop: *EventLoop,
                comptime T: type,
                fd: c_int,
                mask: EventMask,
                comptime func: fn (fd: c_int, mask: EventMask, data: T) c_int,
                data: T,
            ) error{AddFdFailed}!*EventSource {
                return wl_event_loop_add_fd(
                    loop,
                    fd,
                    mask,
                    struct {
                        fn _wrapper(_fd: c_int, _mask: u32, _data: ?*anyopaque) callconv(.c) c_int {
                            return func(_fd, @bitCast(_mask), @ptrCast(@alignCast(_data)));
                        }
                    }._wrapper,
                    data,
                ) orelse error.AddFdFailed;
            }

            extern fn wl_event_loop_add_timer(
                loop: *EventLoop,
                func: *const fn (data: ?*anyopaque) callconv(.c) c_int,
                data: ?*anyopaque,
            ) ?*EventSource;
            pub inline fn addTimer(
                loop: *EventLoop,
                comptime T: type,
                comptime func: fn (data: T) c_int,
                data: T,
            ) error{AddTimerFailed}!*EventSource {
                return wl_event_loop_add_timer(
                    loop,
                    struct {
                        fn _wrapper(_data: ?*anyopaque) callconv(.c) c_int {
                            return func(@ptrCast(@alignCast(_data)));
                        }
                    }._wrapper,
                    data,
                ) orelse error.AddTimerFailed;
            }

            extern fn wl_event_loop_add_signal(
                loop: *EventLoop,
                signal_number: c_int,
                func: *const fn (c_int, ?*anyopaque) callconv(.c) c_int,
                data: ?*anyopaque,
            ) ?*EventSource;
            pub inline fn addSignal(
                loop: *EventLoop,
                comptime T: type,
                signal_number: c_int,
                comptime func: fn (signal_number: c_int, data: T) c_int,
                data: T,
            ) error{AddSignalFailed}!*EventSource {
                return wl_event_loop_add_signal(
                    loop,
                    signal_number,
                    struct {
                        fn _wrapper(_signal_number: c_int, _data: ?*anyopaque) callconv(.c) c_int {
                            return func(_signal_number, @ptrCast(@alignCast(_data)));
                        }
                    }._wrapper,
                    data,
                ) orelse error.AddSignalFailed;
            }

            extern fn wl_event_loop_add_idle(
                loop: *EventLoop,
                func: *const fn (data: ?*anyopaque) callconv(.c) void,
                data: ?*anyopaque,
            ) ?*EventSource;
            pub inline fn addIdle(
                loop: *EventLoop,
                comptime T: type,
                comptime func: fn (data: T) void,
                data: T,
            ) error{OutOfMemory}!*EventSource {
                return wl_event_loop_add_idle(
                    loop,
                    struct {
                        fn _wrapper(_data: ?*anyopaque) callconv(.c) void {
                            return func(@ptrCast(@alignCast(_data)));
                        }
                    }._wrapper,
                    data,
                ) orelse error.OutOfMemory;
            }

            extern fn wl_event_loop_dispatch(loop: *EventLoop, timeout: c_int) c_int;
            pub fn dispatch(loop: *EventLoop, timeout: c_int) !void {
                const rc = wl_event_loop_dispatch(loop, timeout);
                switch (posix.errno(rc)) {
                    .SUCCESS => return,
                    // TODO
                    else => |err| return posix.unexpectedErrno(err),
                }
            }

            extern fn wl_event_loop_dispatch_idle(loop: *EventLoop) void;
            pub const dispatchIdle = wl_event_loop_dispatch_idle;

            extern fn wl_event_loop_get_fd(loop: *EventLoop) c_int;
            pub const getFd = wl_event_loop_get_fd;

            extern fn wl_event_loop_add_destroy_listener(loop: *EventLoop, listener: *Listener(*EventLoop)) void;
            pub const addDestroyListener = wl_event_loop_add_destroy_listener;

            //extern fn wl_event_loop_get_destroy_listener(loop: *EventLoop, notify: @TypeOf(Listener(*EventLoop).notify)) ?*Listener;
            //pub const getDestroyListener = wl_event_loop_get_destroy_listener;
        };

        pub const EventSource = opaque {
            extern fn wl_event_source_remove(source: *EventSource) c_int;
            pub fn remove(source: *EventSource) void {
                if (wl_event_source_remove(source) != 0) unreachable;
            }

            extern fn wl_event_source_check(source: *EventSource) void;
            pub const check = wl_event_source_check;

            extern fn wl_event_source_fd_update(source: *EventSource, mask: u32) c_int;
            pub fn fdUpdate(source: *EventSource, mask: EventMask) !void {
                const rc = wl_event_source_fd_update(source, @bitCast(mask));
                switch (posix.errno(rc)) {
                    .SUCCESS => return,
                    // TODO
                    else => |err| return posix.unexpectedErrno(err),
                }
            }

            extern fn wl_event_source_timer_update(source: *EventSource, ms_delay: c_int) c_int;
            pub fn timerUpdate(source: *EventSource, ms_delay: c_int) !void {
                const rc = wl_event_source_timer_update(source, ms_delay);
                switch (posix.errno(rc)) {
                    .SUCCESS => return,
                    // TODO
                    else => |err| return posix.unexpectedErrno(err),
                }
            }
        };

        pub const shm = struct {
            pub const Buffer = opaque {
                extern fn wl_shm_buffer_get(resource: *Resource) ?*shm.Buffer;
                pub const get = wl_shm_buffer_get;

                extern fn wl_shm_buffer_begin_access(buffer: *shm.Buffer) void;
                pub const beginAccess = wl_shm_buffer_begin_access;

                extern fn wl_shm_buffer_end_access(buffer: *shm.Buffer) void;
                pub const endAccess = wl_shm_buffer_end_access;

                extern fn wl_shm_buffer_get_data(buffer: *shm.Buffer) ?*anyopaque;
                pub const getData = wl_shm_buffer_get_data;

                extern fn wl_shm_buffer_get_format(buffer: *shm.Buffer) u32;
                pub const getFormat = wl_shm_buffer_get_format;

                extern fn wl_shm_buffer_get_height(buffer: *shm.Buffer) i32;
                pub const getHeight = wl_shm_buffer_get_height;

                extern fn wl_shm_buffer_get_width(buffer: *shm.Buffer) i32;
                pub const getWidth = wl_shm_buffer_get_width;

                extern fn wl_shm_buffer_get_stride(buffer: *shm.Buffer) i32;
                pub const getStride = wl_shm_buffer_get_stride;

                extern fn wl_shm_buffer_ref_pool(buffer: *shm.Buffer) *Pool;
                pub const refPool = wl_shm_buffer_ref_pool;
            };

            pub const Pool = opaque {
                extern fn wl_shm_pool_unref(pool: *Pool) void;
                pub const unref = wl_shm_pool_unref;
            };
        };

        /// The core global object.  This is a special singleton object.  It
        /// is used for internal Wayland protocol features.
        pub const Display = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.display.interface;
            pub const Error = common.wl.display.Error;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Display {
                return @ptrCast(try server.wl.Resource.create(_client, Display, _version, _id));
            }
            pub fn destroy(_display: *Display) void {
                return @as(*server.wl.Resource, @ptrCast(_display)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Display {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_display: *Display) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_display)).getLink();
            }
            pub fn getClient(_display: *Display) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_display)).getClient();
            }
            pub fn getId(_display: *Display) u32 {
                return @as(*server.wl.Resource, @ptrCast(_display)).getId();
            }
            pub fn getVersion(_display: *Display) u32 {
                return @as(*server.wl.Resource, @ptrCast(_display)).getVersion();
            }
            pub fn postNoMemory(_display: *Display) void {
                return @as(*server.wl.Resource, @ptrCast(_display)).postNoMemory();
            }
            pub fn getUserData(_display: *Display) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_display)).getUserData();
            }
            pub fn postError(_display: *Display, _err: Error, _message: [*:0]const u8) void {
                return @as(*server.wl.Resource, @ptrCast(_display)).postError(@intCast(@intFromEnum(_err)), _message);
            }
            pub const Request = union(enum) {
                /// The sync request asks the server to emit the 'done' event
                /// on the returned wl_callback object.  Since requests are
                /// handled in-order and events are delivered in-order, this can
                /// be used as a barrier to ensure all previous requests and the
                /// resulting events have been handled.
                ///
                /// The object returned by this request will be destroyed by the
                /// compositor after the callback is fired and as such the client must not
                /// attempt to use it after that point.
                ///
                /// The callback_data passed in the callback is undefined and should be ignored.
                sync: struct {
                    callback: u32,
                },

                /// This request creates a registry object that allows the client
                /// to list and bind the global objects available from the
                /// compositor.
                ///
                /// It should be noted that the server side resources consumed in
                /// response to a get_registry request can only be released when the
                /// client disconnects, not when the client side proxy is destroyed.
                /// Therefore, clients should invoke get_registry as infrequently as
                /// possible to avoid wasting memory.
                get_registry: struct {
                    registry: u32,
                },
            };
            pub inline fn setHandler(
                _display: *Display,
                comptime T: type,
                handle_request: *const fn (_display: *Display, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_display: *Display, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_display);
                _resource.setDispatcher(
                    common.Dispatcher(Display, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Display, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// The error event is sent out when a fatal (non-recoverable)
            /// error has occurred.  The object_id argument is the object
            /// where the error occurred, most often in response to a request
            /// to that object.  The code identifies the error and is defined
            /// by the object interface.  As such, each interface defines its
            /// own set of error codes.  The message is a brief description
            /// of the error, for (debugging) convenience.
            pub fn sendError(_display: *Display, _object_id: *common.Object, _code: u32, _message: [*:0]const u8) void {
                const _resource: *server.wl.Resource = @ptrCast(_display);
                var _args = [_]common.Argument{
                    .{ .o = @ptrCast(_object_id) },
                    .{ .u = _code },
                    .{ .s = _message },
                };
                _resource.postEvent(0, &_args);
            }

            /// This event is used internally by the object ID management
            /// logic. When a client deletes an object that it had created,
            /// the server will send this event to acknowledge that it has
            /// seen the delete request. When the client receives this event,
            /// it will know that it can safely reuse the object ID.
            pub fn sendDeleteId(_display: *Display, _id: u32) void {
                const _resource: *server.wl.Resource = @ptrCast(_display);
                var _args = [_]common.Argument{
                    .{ .u = _id },
                };
                _resource.postEvent(1, &_args);
            }
        };

        /// The singleton global registry object.  The server has a number of
        /// global objects that are available to all clients.  These objects
        /// typically represent an actual object in the server (for example,
        /// an input device) or they are singleton objects that provide
        /// extension functionality.
        ///
        /// When a client creates a registry object, the registry object
        /// will emit a global event for each global currently in the
        /// registry.  Globals come and go as a result of device or
        /// monitor hotplugs, reconfiguration or other events, and the
        /// registry will send out global and global_remove events to
        /// keep the client up to date with the changes.  To mark the end
        /// of the initial burst of events, the client can use the
        /// wl_display.sync request immediately after calling
        /// wl_display.get_registry.
        ///
        /// A client can bind to a global object by using the bind
        /// request.  This creates a client-side handle that lets the object
        /// emit events to the client and lets the client invoke requests on
        /// the object.
        pub const Registry = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.registry.interface;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Registry {
                return @ptrCast(try server.wl.Resource.create(_client, Registry, _version, _id));
            }
            pub fn destroy(_registry: *Registry) void {
                return @as(*server.wl.Resource, @ptrCast(_registry)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Registry {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_registry: *Registry) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_registry)).getLink();
            }
            pub fn getClient(_registry: *Registry) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_registry)).getClient();
            }
            pub fn getId(_registry: *Registry) u32 {
                return @as(*server.wl.Resource, @ptrCast(_registry)).getId();
            }
            pub fn getVersion(_registry: *Registry) u32 {
                return @as(*server.wl.Resource, @ptrCast(_registry)).getVersion();
            }
            pub fn postNoMemory(_registry: *Registry) void {
                return @as(*server.wl.Resource, @ptrCast(_registry)).postNoMemory();
            }
            pub fn getUserData(_registry: *Registry) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_registry)).getUserData();
            }
            pub const Request = union(enum) {
                /// Binds a new, client-created object to the server using the
                /// specified name as the identifier.
                bind: struct {
                    name: u32,
                    interface_name: [*:0]const u8,
                    version: u32,
                    id: u32,
                },
            };
            pub inline fn setHandler(
                _registry: *Registry,
                comptime T: type,
                handle_request: *const fn (_registry: *Registry, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_registry: *Registry, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_registry);
                _resource.setDispatcher(
                    common.Dispatcher(Registry, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Registry, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// Notify the client of global objects.
            ///
            /// The event notifies the client that a global object with
            /// the given name is now available, and it implements the
            /// given version of the given interface.
            pub fn sendGlobal(_registry: *Registry, _name: u32, _interface: [*:0]const u8, _version: u32) void {
                const _resource: *server.wl.Resource = @ptrCast(_registry);
                var _args = [_]common.Argument{
                    .{ .u = _name },
                    .{ .s = _interface },
                    .{ .u = _version },
                };
                _resource.postEvent(0, &_args);
            }

            /// Notify the client of removed global objects.
            ///
            /// This event notifies the client that the global identified
            /// by name is no longer available.  If the client bound to
            /// the global using the bind request, the client should now
            /// destroy that object.
            ///
            /// The object remains valid and requests to the object will be
            /// ignored until the client destroys it, to avoid races between
            /// the global going away and a client sending a request to it.
            pub fn sendGlobalRemove(_registry: *Registry, _name: u32) void {
                const _resource: *server.wl.Resource = @ptrCast(_registry);
                var _args = [_]common.Argument{
                    .{ .u = _name },
                };
                _resource.postEvent(1, &_args);
            }
        };

        /// Clients can handle the 'done' event to get notified when
        /// the related request is done.
        ///
        /// Note, because wl_callback objects are created from multiple independent
        /// factory interfaces, the wl_callback interface is frozen at version 1.
        pub const Callback = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.callback.interface;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Callback {
                return @ptrCast(try server.wl.Resource.create(_client, Callback, _version, _id));
            }
            pub fn destroy(_callback: *Callback) void {
                return @as(*server.wl.Resource, @ptrCast(_callback)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Callback {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_callback: *Callback) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_callback)).getLink();
            }
            pub fn getClient(_callback: *Callback) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_callback)).getClient();
            }
            pub fn getId(_callback: *Callback) u32 {
                return @as(*server.wl.Resource, @ptrCast(_callback)).getId();
            }
            pub fn getVersion(_callback: *Callback) u32 {
                return @as(*server.wl.Resource, @ptrCast(_callback)).getVersion();
            }
            pub fn postNoMemory(_callback: *Callback) void {
                return @as(*server.wl.Resource, @ptrCast(_callback)).postNoMemory();
            }
            pub fn getUserData(_callback: *Callback) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_callback)).getUserData();
            }
            pub inline fn setHandler(
                _callback: *Callback,
                comptime T: type,
                comptime handle_destroy: ?fn (_callback: *Callback, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_callback);
                _resource.setDispatcher(
                    null,
                    null,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Callback, @ptrCast(__resource)),
                                @as(?*anyopaque, @ptrFromInt(@intFromPtr(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// Notify the client when the related request is done.
            pub fn destroySendDone(_callback: *Callback, _callback_data: u32) void {
                const _resource: *server.wl.Resource = @ptrCast(_callback);
                var _args = [_]common.Argument{
                    .{ .u = _callback_data },
                };
                _resource.postEvent(0, &_args);
                _resource.destroy();
            }
        };

        /// A buffer provides the content for a wl_surface. Buffers are
        /// created through factory interfaces such as wl_shm, wp_linux_buffer_params
        /// (from the linux-dmabuf protocol extension) or similar. It has a width and
        /// a height and can be attached to a wl_surface, but the mechanism by which a
        /// client provides and updates the contents is defined by the buffer factory
        /// interface.
        ///
        /// Color channels are assumed to be electrical rather than optical (in other
        /// words, encoded with a transfer function) unless otherwise specified. If
        /// the buffer uses a format that has an alpha channel, the alpha channel is
        /// assumed to be premultiplied into the electrical color channel values
        /// (after transfer function encoding) unless otherwise specified.
        ///
        /// Note, because wl_buffer objects are created from multiple independent
        /// factory interfaces, the wl_buffer interface is frozen at version 1.
        pub const Buffer = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.buffer.interface;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Buffer {
                return @ptrCast(try server.wl.Resource.create(_client, Buffer, _version, _id));
            }
            pub fn destroy(_buffer: *Buffer) void {
                return @as(*server.wl.Resource, @ptrCast(_buffer)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Buffer {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_buffer: *Buffer) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_buffer)).getLink();
            }
            pub fn getClient(_buffer: *Buffer) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_buffer)).getClient();
            }
            pub fn getId(_buffer: *Buffer) u32 {
                return @as(*server.wl.Resource, @ptrCast(_buffer)).getId();
            }
            pub fn getVersion(_buffer: *Buffer) u32 {
                return @as(*server.wl.Resource, @ptrCast(_buffer)).getVersion();
            }
            pub fn postNoMemory(_buffer: *Buffer) void {
                return @as(*server.wl.Resource, @ptrCast(_buffer)).postNoMemory();
            }
            pub fn getUserData(_buffer: *Buffer) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_buffer)).getUserData();
            }
            pub const Request = union(enum) {
                /// Destroy a buffer. If and how you need to release the backing
                /// storage is defined by the buffer factory interface.
                ///
                /// For possible side-effects to a surface, see wl_surface.attach.
                destroy: void,
            };
            pub inline fn setHandler(
                _buffer: *Buffer,
                comptime T: type,
                handle_request: *const fn (_buffer: *Buffer, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_buffer: *Buffer, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_buffer);
                _resource.setDispatcher(
                    common.Dispatcher(Buffer, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Buffer, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// Sent when this wl_buffer is no longer used by the compositor.
            ///
            /// For more information on when release events may or may not be sent,
            /// and what consequences it has, please see the description of
            /// wl_surface.attach.
            ///
            /// If a client receives a release event before the frame callback
            /// requested in the same wl_surface.commit that attaches this
            /// wl_buffer to a surface, then the client is immediately free to
            /// reuse the buffer and its backing storage, and does not need a
            /// second buffer for the next surface content update. Typically
            /// this is possible, when the compositor maintains a copy of the
            /// wl_surface contents, e.g. as a GL texture. This is an important
            /// optimization for GL(ES) compositors with wl_shm clients.
            pub fn sendRelease(_buffer: *Buffer) void {
                const _resource: *server.wl.Resource = @ptrCast(_buffer);
                _resource.postEvent(0, null);
            }
        };

        /// A compositor.  This object is a singleton global.  The
        /// compositor is in charge of combining the contents of multiple
        /// surfaces into one displayable output.
        pub const Compositor = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.compositor.interface;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Compositor {
                return @ptrCast(try server.wl.Resource.create(_client, Compositor, _version, _id));
            }
            pub fn destroy(_compositor: *Compositor) void {
                return @as(*server.wl.Resource, @ptrCast(_compositor)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Compositor {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_compositor: *Compositor) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_compositor)).getLink();
            }
            pub fn getClient(_compositor: *Compositor) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_compositor)).getClient();
            }
            pub fn getId(_compositor: *Compositor) u32 {
                return @as(*server.wl.Resource, @ptrCast(_compositor)).getId();
            }
            pub fn getVersion(_compositor: *Compositor) u32 {
                return @as(*server.wl.Resource, @ptrCast(_compositor)).getVersion();
            }
            pub fn postNoMemory(_compositor: *Compositor) void {
                return @as(*server.wl.Resource, @ptrCast(_compositor)).postNoMemory();
            }
            pub fn getUserData(_compositor: *Compositor) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_compositor)).getUserData();
            }
            pub const Request = union(enum) {
                /// Ask the compositor to create a new surface.
                create_surface: struct {
                    id: u32,
                },

                /// Ask the compositor to create a new region.
                create_region: struct {
                    id: u32,
                },
            };
            pub inline fn setHandler(
                _compositor: *Compositor,
                comptime T: type,
                handle_request: *const fn (_compositor: *Compositor, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_compositor: *Compositor, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_compositor);
                _resource.setDispatcher(
                    common.Dispatcher(Compositor, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Compositor, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
        };

        /// A surface is a rectangular area that may be displayed on zero
        /// or more outputs, and shown any number of times at the compositor's
        /// discretion. They can present wl_buffers, receive user input, and
        /// define a local coordinate system.
        ///
        /// The size of a surface (and relative positions on it) is described
        /// in surface-local coordinates, which may differ from the buffer
        /// coordinates of the pixel content, in case a buffer_transform
        /// or a buffer_scale is used.
        ///
        /// A surface without a "role" is fairly useless: a compositor does
        /// not know where, when or how to present it. The role is the
        /// purpose of a wl_surface. Examples of roles are a cursor for a
        /// pointer (as set by wl_pointer.set_cursor), a drag icon
        /// (wl_data_device.start_drag), a sub-surface
        /// (wl_subcompositor.get_subsurface), and a window as defined by a
        /// shell protocol (e.g. wl_shell.get_shell_surface).
        ///
        /// A surface can have only one role at a time. Initially a
        /// wl_surface does not have a role. Once a wl_surface is given a
        /// role, it is set permanently for the whole lifetime of the
        /// wl_surface object. Giving the current role again is allowed,
        /// unless explicitly forbidden by the relevant interface
        /// specification.
        ///
        /// Surface roles are given by requests in other interfaces such as
        /// wl_pointer.set_cursor. The request should explicitly mention
        /// that this request gives a role to a wl_surface. Often, this
        /// request also creates a new protocol object that represents the
        /// role and adds additional functionality to wl_surface. When a
        /// client wants to destroy a wl_surface, they must destroy this role
        /// object before the wl_surface, otherwise a defunct_role_object error is
        /// sent.
        ///
        /// Destroying the role object does not remove the role from the
        /// wl_surface, but it may stop the wl_surface from "playing the role".
        /// For instance, if a wl_subsurface object is destroyed, the wl_surface
        /// it was created for will be unmapped and forget its position and
        /// z-order. It is allowed to create a wl_subsurface for the same
        /// wl_surface again, but it is not allowed to use the wl_surface as
        /// a cursor (cursor is a different role than sub-surface, and role
        /// switching is not allowed).
        pub const Surface = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.surface.interface;
            pub const Error = common.wl.surface.Error;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Surface {
                return @ptrCast(try server.wl.Resource.create(_client, Surface, _version, _id));
            }
            pub fn destroy(_surface: *Surface) void {
                return @as(*server.wl.Resource, @ptrCast(_surface)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Surface {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_surface: *Surface) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_surface)).getLink();
            }
            pub fn getClient(_surface: *Surface) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_surface)).getClient();
            }
            pub fn getId(_surface: *Surface) u32 {
                return @as(*server.wl.Resource, @ptrCast(_surface)).getId();
            }
            pub fn getVersion(_surface: *Surface) u32 {
                return @as(*server.wl.Resource, @ptrCast(_surface)).getVersion();
            }
            pub fn postNoMemory(_surface: *Surface) void {
                return @as(*server.wl.Resource, @ptrCast(_surface)).postNoMemory();
            }
            pub fn getUserData(_surface: *Surface) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_surface)).getUserData();
            }
            pub fn postError(_surface: *Surface, _err: Error, _message: [*:0]const u8) void {
                return @as(*server.wl.Resource, @ptrCast(_surface)).postError(@intCast(@intFromEnum(_err)), _message);
            }
            pub const Request = union(enum) {
                /// Deletes the surface and invalidates its object ID.
                destroy: void,
                /// Set a buffer as the content of this surface.
                ///
                /// The new size of the surface is calculated based on the buffer
                /// size transformed by the inverse buffer_transform and the
                /// inverse buffer_scale. This means that at commit time the supplied
                /// buffer size must be an integer multiple of the buffer_scale. If
                /// that's not the case, an invalid_size error is sent.
                ///
                /// The x and y arguments specify the location of the new pending
                /// buffer's upper left corner, relative to the current buffer's upper
                /// left corner, in surface-local coordinates. In other words, the
                /// x and y, combined with the new surface size define in which
                /// directions the surface's size changes. Setting anything other than 0
                /// as x and y arguments is discouraged, and should instead be replaced
                /// with using the separate wl_surface.offset request.
                ///
                /// When the bound wl_surface version is 5 or higher, passing any
                /// non-zero x or y is a protocol violation, and will result in an
                /// 'invalid_offset' error being raised. The x and y arguments are ignored
                /// and do not change the pending state. To achieve equivalent semantics,
                /// use wl_surface.offset.
                ///
                /// Surface contents are double-buffered state, see wl_surface.commit.
                ///
                /// The initial surface contents are void; there is no content.
                /// wl_surface.attach assigns the given wl_buffer as the pending
                /// wl_buffer. wl_surface.commit makes the pending wl_buffer the new
                /// surface contents, and the size of the surface becomes the size
                /// calculated from the wl_buffer, as described above. After commit,
                /// there is no pending buffer until the next attach.
                ///
                /// Committing a pending wl_buffer allows the compositor to read the
                /// pixels in the wl_buffer. The compositor may access the pixels at
                /// any time after the wl_surface.commit request. When the compositor
                /// will not access the pixels anymore, it will send the
                /// wl_buffer.release event. Only after receiving wl_buffer.release,
                /// the client may reuse the wl_buffer. A wl_buffer that has been
                /// attached and then replaced by another attach instead of committed
                /// will not receive a release event, and is not used by the
                /// compositor.
                ///
                /// If a pending wl_buffer has been committed to more than one wl_surface,
                /// the delivery of wl_buffer.release events becomes undefined. A well
                /// behaved client should not rely on wl_buffer.release events in this
                /// case. Alternatively, a client could create multiple wl_buffer objects
                /// from the same backing storage or use a protocol extension providing
                /// per-commit release notifications.
                ///
                /// Destroying the wl_buffer after wl_buffer.release does not change
                /// the surface contents. Destroying the wl_buffer before wl_buffer.release
                /// is allowed as long as the underlying buffer storage isn't re-used (this
                /// can happen e.g. on client process termination). However, if the client
                /// destroys the wl_buffer before receiving the wl_buffer.release event and
                /// mutates the underlying buffer storage, the surface contents become
                /// undefined immediately.
                ///
                /// If wl_surface.attach is sent with a NULL wl_buffer, the
                /// following wl_surface.commit will remove the surface content.
                ///
                /// If a pending wl_buffer has been destroyed, the result is not specified.
                /// Many compositors are known to remove the surface content on the following
                /// wl_surface.commit, but this behaviour is not universal. Clients seeking to
                /// maximise compatibility should not destroy pending buffers and should
                /// ensure that they explicitly remove content from surfaces, even after
                /// destroying buffers.
                attach: struct {
                    buffer: ?*server.wl.Buffer,
                    x: i32,
                    y: i32,
                },

                /// This request is used to describe the regions where the pending
                /// buffer is different from the current surface contents, and where
                /// the surface therefore needs to be repainted. The compositor
                /// ignores the parts of the damage that fall outside of the surface.
                ///
                /// Damage is double-buffered state, see wl_surface.commit.
                ///
                /// The damage rectangle is specified in surface-local coordinates,
                /// where x and y specify the upper left corner of the damage rectangle.
                ///
                /// The initial value for pending damage is empty: no damage.
                /// wl_surface.damage adds pending damage: the new pending damage
                /// is the union of old pending damage and the given rectangle.
                ///
                /// wl_surface.commit assigns pending damage as the current damage,
                /// and clears pending damage. The server will clear the current
                /// damage as it repaints the surface.
                ///
                /// Note! New clients should not use this request. Instead damage can be
                /// posted with wl_surface.damage_buffer which uses buffer coordinates
                /// instead of surface coordinates.
                damage: struct {
                    x: i32,
                    y: i32,
                    width: i32,
                    height: i32,
                },

                /// Request a notification when it is a good time to start drawing a new
                /// frame, by creating a frame callback. This is useful for throttling
                /// redrawing operations, and driving animations.
                ///
                /// When a client is animating on a wl_surface, it can use the 'frame'
                /// request to get notified when it is a good time to draw and commit the
                /// next frame of animation. If the client commits an update earlier than
                /// that, it is likely that some updates will not make it to the display,
                /// and the client is wasting resources by drawing too often.
                ///
                /// The frame request will take effect on the next wl_surface.commit.
                /// The notification will only be posted for one frame unless
                /// requested again. For a wl_surface, the notifications are posted in
                /// the order the frame requests were committed.
                ///
                /// The server must send the notifications so that a client
                /// will not send excessive updates, while still allowing
                /// the highest possible update rate for clients that wait for the reply
                /// before drawing again. The server should give some time for the client
                /// to draw and commit after sending the frame callback events to let it
                /// hit the next output refresh.
                ///
                /// A server should avoid signaling the frame callbacks if the
                /// surface is not visible in any way, e.g. the surface is off-screen,
                /// or completely obscured by other opaque surfaces.
                ///
                /// The object returned by this request will be destroyed by the
                /// compositor after the callback is fired and as such the client must not
                /// attempt to use it after that point.
                ///
                /// The callback_data passed in the callback is the current time, in
                /// milliseconds, with an undefined base.
                frame: struct {
                    callback: u32,
                },

                /// This request sets the region of the surface that contains
                /// opaque content.
                ///
                /// The opaque region is an optimization hint for the compositor
                /// that lets it optimize the redrawing of content behind opaque
                /// regions.  Setting an opaque region is not required for correct
                /// behaviour, but marking transparent content as opaque will result
                /// in repaint artifacts.
                ///
                /// The opaque region is specified in surface-local coordinates.
                ///
                /// The compositor ignores the parts of the opaque region that fall
                /// outside of the surface.
                ///
                /// Opaque region is double-buffered state, see wl_surface.commit.
                ///
                /// wl_surface.set_opaque_region changes the pending opaque region.
                /// wl_surface.commit copies the pending region to the current region.
                /// Otherwise, the pending and current regions are never changed.
                ///
                /// The initial value for an opaque region is empty. Setting the pending
                /// opaque region has copy semantics, and the wl_region object can be
                /// destroyed immediately. A NULL wl_region causes the pending opaque
                /// region to be set to empty.
                set_opaque_region: struct {
                    region: ?*server.wl.Region,
                },

                /// This request sets the region of the surface that can receive
                /// pointer and touch events.
                ///
                /// Input events happening outside of this region will try the next
                /// surface in the server surface stack. The compositor ignores the
                /// parts of the input region that fall outside of the surface.
                ///
                /// The input region is specified in surface-local coordinates.
                ///
                /// Input region is double-buffered state, see wl_surface.commit.
                ///
                /// wl_surface.set_input_region changes the pending input region.
                /// wl_surface.commit copies the pending region to the current region.
                /// Otherwise the pending and current regions are never changed,
                /// except cursor and icon surfaces are special cases, see
                /// wl_pointer.set_cursor and wl_data_device.start_drag.
                ///
                /// The initial value for an input region is infinite. That means the
                /// whole surface will accept input. Setting the pending input region
                /// has copy semantics, and the wl_region object can be destroyed
                /// immediately. A NULL wl_region causes the input region to be set
                /// to infinite.
                set_input_region: struct {
                    region: ?*server.wl.Region,
                },

                /// Surface state (input, opaque, and damage regions, attached buffers,
                /// etc.) is double-buffered. Protocol requests modify the pending state,
                /// as opposed to the active state in use by the compositor.
                ///
                /// A commit request atomically creates a content update from the pending
                /// state, even if the pending state has not been touched. The content
                /// update is placed in a queue until it becomes active. After commit, the
                /// new pending state is as documented for each related request.
                ///
                /// When the content update is applied, the wl_buffer is applied before all
                /// other state. This means that all coordinates in double-buffered state
                /// are relative to the newly attached wl_buffers, except for
                /// wl_surface.attach itself. If there is no newly attached wl_buffer, the
                /// coordinates are relative to the previous content update.
                ///
                /// All requests that need a commit to become effective are documented
                /// to affect double-buffered state.
                ///
                /// Other interfaces may add further double-buffered surface state.
                commit: void,
                /// This request sets the transformation that the client has already applied
                /// to the content of the buffer. The accepted values for the transform
                /// parameter are the values for wl_output.transform.
                ///
                /// The compositor applies the inverse of this transformation whenever it
                /// uses the buffer contents.
                ///
                /// Buffer transform is double-buffered state, see wl_surface.commit.
                ///
                /// A newly created surface has its buffer transformation set to normal.
                ///
                /// wl_surface.set_buffer_transform changes the pending buffer
                /// transformation. wl_surface.commit copies the pending buffer
                /// transformation to the current one. Otherwise, the pending and current
                /// values are never changed.
                ///
                /// The purpose of this request is to allow clients to render content
                /// according to the output transform, thus permitting the compositor to
                /// use certain optimizations even if the display is rotated. Using
                /// hardware overlays and scanning out a client buffer for fullscreen
                /// surfaces are examples of such optimizations. Those optimizations are
                /// highly dependent on the compositor implementation, so the use of this
                /// request should be considered on a case-by-case basis.
                ///
                /// Note that if the transform value includes 90 or 270 degree rotation,
                /// the width of the buffer will become the surface height and the height
                /// of the buffer will become the surface width.
                ///
                /// If transform is not one of the values from the
                /// wl_output.transform enum the invalid_transform protocol error
                /// is raised.
                set_buffer_transform: struct {
                    transform: common.wl.output.Transform,
                },

                /// This request sets an optional scaling factor on how the compositor
                /// interprets the contents of the buffer attached to the window.
                ///
                /// Buffer scale is double-buffered state, see wl_surface.commit.
                ///
                /// A newly created surface has its buffer scale set to 1.
                ///
                /// wl_surface.set_buffer_scale changes the pending buffer scale.
                /// wl_surface.commit copies the pending buffer scale to the current one.
                /// Otherwise, the pending and current values are never changed.
                ///
                /// The purpose of this request is to allow clients to supply higher
                /// resolution buffer data for use on high resolution outputs. It is
                /// intended that you pick the same buffer scale as the scale of the
                /// output that the surface is displayed on. This means the compositor
                /// can avoid scaling when rendering the surface on that output.
                ///
                /// Note that if the scale is larger than 1, then you have to attach
                /// a buffer that is larger (by a factor of scale in each dimension)
                /// than the desired surface size.
                ///
                /// If scale is not greater than 0 the invalid_scale protocol error is
                /// raised.
                set_buffer_scale: struct {
                    scale: i32,
                },

                /// This request is used to describe the regions where the pending
                /// buffer is different from the current surface contents, and where
                /// the surface therefore needs to be repainted. The compositor
                /// ignores the parts of the damage that fall outside of the surface.
                ///
                /// Damage is double-buffered state, see wl_surface.commit.
                ///
                /// The damage rectangle is specified in buffer coordinates,
                /// where x and y specify the upper left corner of the damage rectangle.
                ///
                /// The initial value for pending damage is empty: no damage.
                /// wl_surface.damage_buffer adds pending damage: the new pending
                /// damage is the union of old pending damage and the given rectangle.
                ///
                /// wl_surface.commit assigns pending damage as the current damage,
                /// and clears pending damage. The server will clear the current
                /// damage as it repaints the surface.
                ///
                /// This request differs from wl_surface.damage in only one way - it
                /// takes damage in buffer coordinates instead of surface-local
                /// coordinates. While this generally is more intuitive than surface
                /// coordinates, it is especially desirable when using wp_viewport
                /// or when a drawing library (like EGL) is unaware of buffer scale
                /// and buffer transform.
                ///
                /// Note: Because buffer transformation changes and damage requests may
                /// be interleaved in the protocol stream, it is impossible to determine
                /// the actual mapping between surface and buffer damage until
                /// wl_surface.commit time. Therefore, compositors wishing to take both
                /// kinds of damage into account will have to accumulate damage from the
                /// two requests separately and only transform from one to the other
                /// after receiving the wl_surface.commit.
                damage_buffer: struct {
                    x: i32,
                    y: i32,
                    width: i32,
                    height: i32,
                },

                /// The x and y arguments specify the location of the new pending
                /// buffer's upper left corner, relative to the current buffer's upper
                /// left corner, in surface-local coordinates. In other words, the
                /// x and y, combined with the new surface size define in which
                /// directions the surface's size changes.
                ///
                /// The exact semantics of wl_surface.offset are role-specific. Refer to
                /// the documentation of specific roles for more information.
                ///
                /// Surface location offset is double-buffered state, see
                /// wl_surface.commit.
                ///
                /// This request is semantically equivalent to and the replaces the x and y
                /// arguments in the wl_surface.attach request in wl_surface versions prior
                /// to 5. See wl_surface.attach for details.
                offset: struct {
                    x: i32,
                    y: i32,
                },
            };
            pub inline fn setHandler(
                _surface: *Surface,
                comptime T: type,
                handle_request: *const fn (_surface: *Surface, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_surface: *Surface, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_surface);
                _resource.setDispatcher(
                    common.Dispatcher(Surface, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Surface, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// This is emitted whenever a surface's creation, movement, or resizing
            /// results in some part of it being within the scanout region of an
            /// output.
            ///
            /// Note that a surface may be overlapping with zero or more outputs.
            pub fn sendEnter(_surface: *Surface, _output: *server.wl.Output) void {
                const _resource: *server.wl.Resource = @ptrCast(_surface);
                var _args = [_]common.Argument{
                    .{ .o = @ptrCast(_output) },
                };
                _resource.postEvent(0, &_args);
            }

            /// This is emitted whenever a surface's creation, movement, or resizing
            /// results in it no longer having any part of it within the scanout region
            /// of an output.
            ///
            /// Clients should not use the number of outputs the surface is on for frame
            /// throttling purposes. The surface might be hidden even if no leave event
            /// has been sent, and the compositor might expect new surface content
            /// updates even if no enter event has been sent. The frame event should be
            /// used instead.
            pub fn sendLeave(_surface: *Surface, _output: *server.wl.Output) void {
                const _resource: *server.wl.Resource = @ptrCast(_surface);
                var _args = [_]common.Argument{
                    .{ .o = @ptrCast(_output) },
                };
                _resource.postEvent(1, &_args);
            }
        };

        /// A region object describes an area.
        ///
        /// Region objects are used to describe the opaque and input
        /// regions of a surface.
        pub const Region = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.region.interface;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Region {
                return @ptrCast(try server.wl.Resource.create(_client, Region, _version, _id));
            }
            pub fn destroy(_region: *Region) void {
                return @as(*server.wl.Resource, @ptrCast(_region)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Region {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_region: *Region) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_region)).getLink();
            }
            pub fn getClient(_region: *Region) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_region)).getClient();
            }
            pub fn getId(_region: *Region) u32 {
                return @as(*server.wl.Resource, @ptrCast(_region)).getId();
            }
            pub fn getVersion(_region: *Region) u32 {
                return @as(*server.wl.Resource, @ptrCast(_region)).getVersion();
            }
            pub fn postNoMemory(_region: *Region) void {
                return @as(*server.wl.Resource, @ptrCast(_region)).postNoMemory();
            }
            pub fn getUserData(_region: *Region) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_region)).getUserData();
            }
            pub const Request = union(enum) {
                /// Destroy the region.  This will invalidate the object ID.
                destroy: void,
                /// Add the specified rectangle to the region.
                add: struct {
                    x: i32,
                    y: i32,
                    width: i32,
                    height: i32,
                },

                /// Subtract the specified rectangle from the region.
                subtract: struct {
                    x: i32,
                    y: i32,
                    width: i32,
                    height: i32,
                },
            };
            pub inline fn setHandler(
                _region: *Region,
                comptime T: type,
                handle_request: *const fn (_region: *Region, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_region: *Region, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_region);
                _resource.setDispatcher(
                    common.Dispatcher(Region, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Region, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
        };

        /// A singleton global object that provides support for shared
        /// memory.
        ///
        /// Clients can create wl_shm_pool objects using the create_pool
        /// request.
        ///
        /// On binding the wl_shm object one or more format events
        /// are emitted to inform clients about the valid pixel formats
        /// that can be used for buffers.
        pub const Shm = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.shm.interface;
            pub const Error = common.wl.shm.Error;
            pub const Format = common.wl.shm.Format;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Shm {
                return @ptrCast(try server.wl.Resource.create(_client, Shm, _version, _id));
            }
            pub fn destroy(_shm: *Shm) void {
                return @as(*server.wl.Resource, @ptrCast(_shm)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Shm {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_shm: *Shm) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_shm)).getLink();
            }
            pub fn getClient(_shm: *Shm) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_shm)).getClient();
            }
            pub fn getId(_shm: *Shm) u32 {
                return @as(*server.wl.Resource, @ptrCast(_shm)).getId();
            }
            pub fn getVersion(_shm: *Shm) u32 {
                return @as(*server.wl.Resource, @ptrCast(_shm)).getVersion();
            }
            pub fn postNoMemory(_shm: *Shm) void {
                return @as(*server.wl.Resource, @ptrCast(_shm)).postNoMemory();
            }
            pub fn getUserData(_shm: *Shm) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_shm)).getUserData();
            }
            pub fn postError(_shm: *Shm, _err: Error, _message: [*:0]const u8) void {
                return @as(*server.wl.Resource, @ptrCast(_shm)).postError(@intCast(@intFromEnum(_err)), _message);
            }
            pub const Request = union(enum) {
                /// Create a new wl_shm_pool object.
                ///
                /// The pool can be used to create shared memory based buffer
                /// objects.  The server will mmap size bytes of the passed file
                /// descriptor, to use as backing memory for the pool.
                create_pool: struct {
                    id: u32,
                    fd: i32,
                    size: i32,
                },
            };
            pub inline fn setHandler(
                _shm: *Shm,
                comptime T: type,
                handle_request: *const fn (_shm: *Shm, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_shm: *Shm, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_shm);
                _resource.setDispatcher(
                    common.Dispatcher(Shm, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Shm, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// Informs the client about a valid pixel format that
            /// can be used for buffers. Known formats include
            /// argb8888 and xrgb8888.
            pub fn sendFormat(_shm: *Shm, _format: Format) void {
                const _resource: *server.wl.Resource = @ptrCast(_shm);
                var _args = [_]common.Argument{
                    .{ .u = switch (@typeInfo(Format)) {
                        .@"enum" => @as(u32, @intCast(@intFromEnum(_format))),
                        .@"struct" => @bitCast(_format),
                        else => unreachable,
                    } },
                };
                _resource.postEvent(0, &_args);
            }
        };

        /// The wl_shm_pool object encapsulates a piece of memory shared
        /// between the compositor and client.  Through the wl_shm_pool
        /// object, the client can allocate shared memory wl_buffer objects.
        /// All objects created through the same pool share the same
        /// underlying mapped memory. Reusing the mapped memory avoids the
        /// setup/teardown overhead and is useful when interactively resizing
        /// a surface or for many small buffers.
        pub const ShmPool = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.shm_pool.interface;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*ShmPool {
                return @ptrCast(try server.wl.Resource.create(_client, ShmPool, _version, _id));
            }
            pub fn destroy(_shm_pool: *ShmPool) void {
                return @as(*server.wl.Resource, @ptrCast(_shm_pool)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *ShmPool {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_shm_pool: *ShmPool) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_shm_pool)).getLink();
            }
            pub fn getClient(_shm_pool: *ShmPool) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_shm_pool)).getClient();
            }
            pub fn getId(_shm_pool: *ShmPool) u32 {
                return @as(*server.wl.Resource, @ptrCast(_shm_pool)).getId();
            }
            pub fn getVersion(_shm_pool: *ShmPool) u32 {
                return @as(*server.wl.Resource, @ptrCast(_shm_pool)).getVersion();
            }
            pub fn postNoMemory(_shm_pool: *ShmPool) void {
                return @as(*server.wl.Resource, @ptrCast(_shm_pool)).postNoMemory();
            }
            pub fn getUserData(_shm_pool: *ShmPool) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_shm_pool)).getUserData();
            }
            pub const Request = union(enum) {
                /// Create a wl_buffer object from the pool.
                ///
                /// The buffer is created offset bytes into the pool and has
                /// width and height as specified.  The stride argument specifies
                /// the number of bytes from the beginning of one row to the beginning
                /// of the next.  The format is the pixel format of the buffer and
                /// must be one of those advertised through the wl_shm.format event.
                ///
                /// A buffer will keep a reference to the pool it was created from
                /// so it is valid to destroy the pool immediately after creating
                /// a buffer from it.
                create_buffer: struct {
                    id: u32,
                    offset: i32,
                    width: i32,
                    height: i32,
                    stride: i32,
                    format: common.wl.shm.Format,
                },

                /// Destroy the shared memory pool.
                ///
                /// The mmapped memory will be released when all
                /// buffers that have been created from this pool
                /// are gone.
                destroy: void,
                /// This request will cause the server to remap the backing memory
                /// for the pool from the file descriptor passed when the pool was
                /// created, but using the new size.  This request can only be
                /// used to make the pool bigger.
                ///
                /// This request only changes the amount of bytes that are mmapped
                /// by the server and does not touch the file corresponding to the
                /// file descriptor passed at creation time. It is the client's
                /// responsibility to ensure that the file is at least as big as
                /// the new pool size.
                resize: struct {
                    size: i32,
                },
            };
            pub inline fn setHandler(
                _shm_pool: *ShmPool,
                comptime T: type,
                handle_request: *const fn (_shm_pool: *ShmPool, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_shm_pool: *ShmPool, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_shm_pool);
                _resource.setDispatcher(
                    common.Dispatcher(ShmPool, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*ShmPool, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
        };

        /// A seat is a group of keyboards, pointer and touch devices. This
        /// object is published as a global during start up, or when such a
        /// device is hot plugged.  A seat typically has a pointer and
        /// maintains a keyboard focus and a pointer focus.
        pub const Seat = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.seat.interface;
            pub const Capability = common.wl.seat.Capability;
            pub const Error = common.wl.seat.Error;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Seat {
                return @ptrCast(try server.wl.Resource.create(_client, Seat, _version, _id));
            }
            pub fn destroy(_seat: *Seat) void {
                return @as(*server.wl.Resource, @ptrCast(_seat)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Seat {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_seat: *Seat) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_seat)).getLink();
            }
            pub fn getClient(_seat: *Seat) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_seat)).getClient();
            }
            pub fn getId(_seat: *Seat) u32 {
                return @as(*server.wl.Resource, @ptrCast(_seat)).getId();
            }
            pub fn getVersion(_seat: *Seat) u32 {
                return @as(*server.wl.Resource, @ptrCast(_seat)).getVersion();
            }
            pub fn postNoMemory(_seat: *Seat) void {
                return @as(*server.wl.Resource, @ptrCast(_seat)).postNoMemory();
            }
            pub fn getUserData(_seat: *Seat) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_seat)).getUserData();
            }
            pub fn postError(_seat: *Seat, _err: Error, _message: [*:0]const u8) void {
                return @as(*server.wl.Resource, @ptrCast(_seat)).postError(@intCast(@intFromEnum(_err)), _message);
            }
            pub const Request = union(enum) {
                /// The ID provided will be initialized to the wl_pointer interface
                /// for this seat.
                ///
                /// This request only takes effect if the seat has the pointer
                /// capability, or has had the pointer capability in the past.
                /// It is a protocol violation to issue this request on a seat that has
                /// never had the pointer capability. The missing_capability error will
                /// be sent in this case.
                get_pointer: struct {
                    id: u32,
                },

                /// The ID provided will be initialized to the wl_keyboard interface
                /// for this seat.
                ///
                /// This request only takes effect if the seat has the keyboard
                /// capability, or has had the keyboard capability in the past.
                /// It is a protocol violation to issue this request on a seat that has
                /// never had the keyboard capability. The missing_capability error will
                /// be sent in this case.
                get_keyboard: struct {
                    id: u32,
                },

                /// The ID provided will be initialized to the wl_touch interface
                /// for this seat.
                ///
                /// This request only takes effect if the seat has the touch
                /// capability, or has had the touch capability in the past.
                /// It is a protocol violation to issue this request on a seat that has
                /// never had the touch capability. The missing_capability error will
                /// be sent in this case.
                get_touch: struct {
                    id: u32,
                },

                /// Using this request a client can tell the server that it is not going to
                /// use the seat object anymore.
                release: void,
            };
            pub inline fn setHandler(
                _seat: *Seat,
                comptime T: type,
                handle_request: *const fn (_seat: *Seat, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_seat: *Seat, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_seat);
                _resource.setDispatcher(
                    common.Dispatcher(Seat, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Seat, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// This is sent on binding to the seat global or whenever a seat gains
            /// or loses the pointer, keyboard or touch capabilities.
            /// The argument is a capability enum containing the complete set of
            /// capabilities this seat has.
            ///
            /// When the pointer capability is added, a client may create a
            /// wl_pointer object using the wl_seat.get_pointer request. This object
            /// will receive pointer events until the capability is removed in the
            /// future.
            ///
            /// When the pointer capability is removed, a client should destroy the
            /// wl_pointer objects associated with the seat where the capability was
            /// removed, using the wl_pointer.release request. No further pointer
            /// events will be received on these objects.
            ///
            /// In some compositors, if a seat regains the pointer capability and a
            /// client has a previously obtained wl_pointer object of version 4 or
            /// less, that object may start sending pointer events again. This
            /// behavior is considered a misinterpretation of the intended behavior
            /// and must not be relied upon by the client. wl_pointer objects of
            /// version 5 or later must not send events if created before the most
            /// recent event notifying the client of an added pointer capability.
            ///
            /// The above behavior also applies to wl_keyboard and wl_touch with the
            /// keyboard and touch capabilities, respectively.
            pub fn sendCapabilities(_seat: *Seat, _capabilities: Capability) void {
                const _resource: *server.wl.Resource = @ptrCast(_seat);
                var _args = [_]common.Argument{
                    .{ .u = switch (@typeInfo(Capability)) {
                        .@"enum" => @as(u32, @intCast(@intFromEnum(_capabilities))),
                        .@"struct" => @bitCast(_capabilities),
                        else => unreachable,
                    } },
                };
                _resource.postEvent(0, &_args);
            }

            /// In a multi-seat configuration the seat name can be used by clients to
            /// help identify which physical devices the seat represents.
            ///
            /// The seat name is a UTF-8 string with no convention defined for its
            /// contents. Each name is unique among all wl_seat globals. The name is
            /// only guaranteed to be unique for the current compositor instance.
            ///
            /// The same seat names are used for all clients. Thus, the name can be
            /// shared across processes to refer to a specific wl_seat global.
            ///
            /// The name event is sent after binding to the seat global, and should be sent
            /// before announcing capabilities. This event only sent once per seat object,
            /// and the name does not change over the lifetime of the wl_seat global.
            ///
            /// Compositors may re-use the same seat name if the wl_seat global is
            /// destroyed and re-created later.
            pub fn sendName(_seat: *Seat, _name: [*:0]const u8) void {
                const _resource: *server.wl.Resource = @ptrCast(_seat);
                var _args = [_]common.Argument{
                    .{ .s = _name },
                };
                _resource.postEvent(1, &_args);
            }
        };

        /// The wl_pointer interface represents one or more input devices,
        /// such as mice, which control the pointer location and pointer_focus
        /// of a seat.
        ///
        /// The wl_pointer interface generates motion, enter and leave
        /// events for the surfaces that the pointer is located over,
        /// and button and axis events for button presses, button releases
        /// and scrolling.
        pub const Pointer = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.pointer.interface;
            pub const Error = common.wl.pointer.Error;
            pub const ButtonState = common.wl.pointer.ButtonState;
            pub const Axis = common.wl.pointer.Axis;
            pub const AxisSource = common.wl.pointer.AxisSource;
            pub const AxisRelativeDirection = common.wl.pointer.AxisRelativeDirection;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Pointer {
                return @ptrCast(try server.wl.Resource.create(_client, Pointer, _version, _id));
            }
            pub fn destroy(_pointer: *Pointer) void {
                return @as(*server.wl.Resource, @ptrCast(_pointer)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Pointer {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_pointer: *Pointer) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_pointer)).getLink();
            }
            pub fn getClient(_pointer: *Pointer) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_pointer)).getClient();
            }
            pub fn getId(_pointer: *Pointer) u32 {
                return @as(*server.wl.Resource, @ptrCast(_pointer)).getId();
            }
            pub fn getVersion(_pointer: *Pointer) u32 {
                return @as(*server.wl.Resource, @ptrCast(_pointer)).getVersion();
            }
            pub fn postNoMemory(_pointer: *Pointer) void {
                return @as(*server.wl.Resource, @ptrCast(_pointer)).postNoMemory();
            }
            pub fn getUserData(_pointer: *Pointer) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_pointer)).getUserData();
            }
            pub fn postError(_pointer: *Pointer, _err: Error, _message: [*:0]const u8) void {
                return @as(*server.wl.Resource, @ptrCast(_pointer)).postError(@intCast(@intFromEnum(_err)), _message);
            }
            pub const Request = union(enum) {
                /// Set the pointer surface, i.e., the surface that contains the
                /// pointer image (cursor). This request gives the surface the role
                /// of a cursor. If the surface already has another role, it raises
                /// a protocol error.
                ///
                /// The cursor actually changes only if the pointer
                /// focus for this device is one of the requesting client's surfaces
                /// or the surface parameter is the current pointer surface. If
                /// there was a previous surface set with this request it is
                /// replaced. If surface is NULL, the pointer image is hidden.
                ///
                /// The parameters hotspot_x and hotspot_y define the position of
                /// the pointer surface relative to the pointer location. Its
                /// top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
                /// where (x, y) are the coordinates of the pointer location, in
                /// surface-local coordinates.
                ///
                /// On wl_surface.offset requests to the pointer surface, hotspot_x
                /// and hotspot_y are decremented by the x and y parameters
                /// passed to the request. The offset must be applied by
                /// wl_surface.commit as usual.
                ///
                /// The hotspot can also be updated by passing the currently set
                /// pointer surface to this request with new values for hotspot_x
                /// and hotspot_y.
                ///
                /// The input region is ignored for wl_surfaces with the role of
                /// a cursor. When the use as a cursor ends, the wl_surface is
                /// unmapped.
                ///
                /// The serial parameter must match the latest wl_pointer.enter
                /// serial number sent to the client. Otherwise the request will be
                /// ignored.
                set_cursor: struct {
                    serial: u32,
                    surface: ?*server.wl.Surface,
                    hotspot_x: i32,
                    hotspot_y: i32,
                },

                /// Using this request a client can tell the server that it is not going to
                /// use the pointer object anymore.
                ///
                /// This request destroys the pointer proxy object, so clients must not call
                /// wl_pointer_destroy() after using this request.
                release: void,
            };
            pub inline fn setHandler(
                _pointer: *Pointer,
                comptime T: type,
                handle_request: *const fn (_pointer: *Pointer, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_pointer: *Pointer, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_pointer);
                _resource.setDispatcher(
                    common.Dispatcher(Pointer, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Pointer, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// Notification that this seat's pointer is focused on a certain
            /// surface.
            ///
            /// When a seat's focus enters a surface, the pointer image
            /// is undefined and a client should respond to this event by setting
            /// an appropriate pointer image with the set_cursor request.
            pub fn sendEnter(_pointer: *Pointer, _serial: u32, _surface: *server.wl.Surface, _surface_x: common.Fixed, _surface_y: common.Fixed) void {
                const _resource: *server.wl.Resource = @ptrCast(_pointer);
                var _args = [_]common.Argument{
                    .{ .u = _serial },
                    .{ .o = @ptrCast(_surface) },
                    .{ .f = _surface_x },
                    .{ .f = _surface_y },
                };
                _resource.postEvent(0, &_args);
            }

            /// Notification that this seat's pointer is no longer focused on
            /// a certain surface.
            ///
            /// The leave notification is sent before the enter notification
            /// for the new focus.
            pub fn sendLeave(_pointer: *Pointer, _serial: u32, _surface: *server.wl.Surface) void {
                const _resource: *server.wl.Resource = @ptrCast(_pointer);
                var _args = [_]common.Argument{
                    .{ .u = _serial },
                    .{ .o = @ptrCast(_surface) },
                };
                _resource.postEvent(1, &_args);
            }

            /// Notification of pointer location change. The arguments
            /// surface_x and surface_y are the location relative to the
            /// focused surface.
            pub fn sendMotion(_pointer: *Pointer, _time: u32, _surface_x: common.Fixed, _surface_y: common.Fixed) void {
                const _resource: *server.wl.Resource = @ptrCast(_pointer);
                var _args = [_]common.Argument{
                    .{ .u = _time },
                    .{ .f = _surface_x },
                    .{ .f = _surface_y },
                };
                _resource.postEvent(2, &_args);
            }

            /// Mouse button click and release notifications.
            ///
            /// The location of the click is given by the last motion or
            /// enter event.
            /// The time argument is a timestamp with millisecond
            /// granularity, with an undefined base.
            ///
            /// The button is a button code as defined in the Linux kernel's
            /// linux/input-event-codes.h header file, e.g. BTN_LEFT.
            ///
            /// Any 16-bit button code value is reserved for future additions to the
            /// kernel's event code list. All other button codes above 0xFFFF are
            /// currently undefined but may be used in future versions of this
            /// protocol.
            pub fn sendButton(_pointer: *Pointer, _serial: u32, _time: u32, _button: u32, _state: ButtonState) void {
                const _resource: *server.wl.Resource = @ptrCast(_pointer);
                var _args = [_]common.Argument{
                    .{ .u = _serial },
                    .{ .u = _time },
                    .{ .u = _button },
                    .{ .u = switch (@typeInfo(ButtonState)) {
                        .@"enum" => @as(u32, @intCast(@intFromEnum(_state))),
                        .@"struct" => @bitCast(_state),
                        else => unreachable,
                    } },
                };
                _resource.postEvent(3, &_args);
            }

            /// Scroll and other axis notifications.
            ///
            /// For scroll events (vertical and horizontal scroll axes), the
            /// value parameter is the length of a vector along the specified
            /// axis in a coordinate space identical to those of motion events,
            /// representing a relative movement along the specified axis.
            ///
            /// For devices that support movements non-parallel to axes multiple
            /// axis events will be emitted.
            ///
            /// When applicable, for example for touch pads, the server can
            /// choose to emit scroll events where the motion vector is
            /// equivalent to a motion event vector.
            ///
            /// When applicable, a client can transform its content relative to the
            /// scroll distance.
            pub fn sendAxis(_pointer: *Pointer, _time: u32, _axis: Axis, _value: common.Fixed) void {
                const _resource: *server.wl.Resource = @ptrCast(_pointer);
                var _args = [_]common.Argument{
                    .{ .u = _time },
                    .{ .u = switch (@typeInfo(Axis)) {
                        .@"enum" => @as(u32, @intCast(@intFromEnum(_axis))),
                        .@"struct" => @bitCast(_axis),
                        else => unreachable,
                    } },
                    .{ .f = _value },
                };
                _resource.postEvent(4, &_args);
            }

            /// Indicates the end of a set of events that logically belong together.
            /// A client is expected to accumulate the data in all events within the
            /// frame before proceeding.
            ///
            /// All wl_pointer events before a wl_pointer.frame event belong
            /// logically together. For example, in a diagonal scroll motion the
            /// compositor will send an optional wl_pointer.axis_source event, two
            /// wl_pointer.axis events (horizontal and vertical) and finally a
            /// wl_pointer.frame event. The client may use this information to
            /// calculate a diagonal vector for scrolling.
            ///
            /// When multiple wl_pointer.axis events occur within the same frame,
            /// the motion vector is the combined motion of all events.
            /// When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
            /// the same frame, this indicates that axis movement in one axis has
            /// stopped but continues in the other axis.
            /// When multiple wl_pointer.axis_stop events occur within the same
            /// frame, this indicates that these axes stopped in the same instance.
            ///
            /// A wl_pointer.frame event is sent for every logical event group,
            /// even if the group only contains a single wl_pointer event.
            /// Specifically, a client may get a sequence: motion, frame, button,
            /// frame, axis, frame, axis_stop, frame.
            ///
            /// The wl_pointer.enter and wl_pointer.leave events are logical events
            /// generated by the compositor and not the hardware. These events are
            /// also grouped by a wl_pointer.frame. When a pointer moves from one
            /// surface to another, a compositor should group the
            /// wl_pointer.leave event within the same wl_pointer.frame.
            /// However, a client must not rely on wl_pointer.leave and
            /// wl_pointer.enter being in the same wl_pointer.frame.
            /// Compositor-specific policies may require the wl_pointer.leave and
            /// wl_pointer.enter event being split across multiple wl_pointer.frame
            /// groups.
            pub fn sendFrame(_pointer: *Pointer) void {
                const _resource: *server.wl.Resource = @ptrCast(_pointer);
                _resource.postEvent(5, null);
            }

            /// Source information for scroll and other axes.
            ///
            /// This event does not occur on its own. It is sent before a
            /// wl_pointer.frame event and carries the source information for
            /// all events within that frame.
            ///
            /// The source specifies how this event was generated. If the source is
            /// wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
            /// sent when the user lifts the finger off the device.
            ///
            /// If the source is wl_pointer.axis_source.wheel,
            /// wl_pointer.axis_source.wheel_tilt or
            /// wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
            /// or may not be sent. Whether a compositor sends an axis_stop event
            /// for these sources is hardware-specific and implementation-dependent;
            /// clients must not rely on receiving an axis_stop event for these
            /// scroll sources and should treat scroll sequences from these scroll
            /// sources as unterminated by default.
            ///
            /// This event is optional. If the source is unknown for a particular
            /// axis event sequence, no event is sent.
            /// Only one wl_pointer.axis_source event is permitted per frame.
            ///
            /// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
            /// not guaranteed.
            pub fn sendAxisSource(_pointer: *Pointer, _axis_source: AxisSource) void {
                const _resource: *server.wl.Resource = @ptrCast(_pointer);
                var _args = [_]common.Argument{
                    .{ .u = switch (@typeInfo(AxisSource)) {
                        .@"enum" => @as(u32, @intCast(@intFromEnum(_axis_source))),
                        .@"struct" => @bitCast(_axis_source),
                        else => unreachable,
                    } },
                };
                _resource.postEvent(6, &_args);
            }

            /// Stop notification for scroll and other axes.
            ///
            /// For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
            /// is sent to notify a client that the axis sequence has terminated.
            /// This enables the client to implement kinetic scrolling.
            /// See the wl_pointer.axis_source documentation for information on when
            /// this event may be generated.
            ///
            /// Any wl_pointer.axis events with the same axis_source after this
            /// event should be considered as the start of a new axis motion.
            ///
            /// The timestamp is to be interpreted identical to the timestamp in the
            /// wl_pointer.axis event. The timestamp value may be the same as a
            /// preceding wl_pointer.axis event.
            pub fn sendAxisStop(_pointer: *Pointer, _time: u32, _axis: Axis) void {
                const _resource: *server.wl.Resource = @ptrCast(_pointer);
                var _args = [_]common.Argument{
                    .{ .u = _time },
                    .{ .u = switch (@typeInfo(Axis)) {
                        .@"enum" => @as(u32, @intCast(@intFromEnum(_axis))),
                        .@"struct" => @bitCast(_axis),
                        else => unreachable,
                    } },
                };
                _resource.postEvent(7, &_args);
            }

            /// Discrete step information for scroll and other axes.
            ///
            /// This event carries the axis value of the wl_pointer.axis event in
            /// discrete steps (e.g. mouse wheel clicks).
            ///
            /// This event is deprecated with wl_pointer version 8 - this event is not
            /// sent to clients supporting version 8 or later.
            ///
            /// This event does not occur on its own, it is coupled with a
            /// wl_pointer.axis event that represents this axis value on a
            /// continuous scale. The protocol guarantees that each axis_discrete
            /// event is always followed by exactly one axis event with the same
            /// axis number within the same wl_pointer.frame. Note that the protocol
            /// allows for other events to occur between the axis_discrete and
            /// its coupled axis event, including other axis_discrete or axis
            /// events. A wl_pointer.frame must not contain more than one axis_discrete
            /// event per axis type.
            ///
            /// This event is optional; continuous scrolling devices
            /// like two-finger scrolling on touchpads do not have discrete
            /// steps and do not generate this event.
            ///
            /// The discrete value carries the directional information. e.g. a value
            /// of -2 is two steps towards the negative direction of this axis.
            ///
            /// The axis number is identical to the axis number in the associated
            /// axis event.
            ///
            /// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
            /// not guaranteed.
            pub fn sendAxisDiscrete(_pointer: *Pointer, _axis: Axis, _discrete: i32) void {
                const _resource: *server.wl.Resource = @ptrCast(_pointer);
                var _args = [_]common.Argument{
                    .{ .u = switch (@typeInfo(Axis)) {
                        .@"enum" => @as(u32, @intCast(@intFromEnum(_axis))),
                        .@"struct" => @bitCast(_axis),
                        else => unreachable,
                    } },
                    .{ .i = _discrete },
                };
                _resource.postEvent(8, &_args);
            }
        };

        /// The wl_keyboard interface represents one or more keyboards
        /// associated with a seat.
        ///
        /// Each wl_keyboard has the following logical state:
        ///
        /// - an active surface (possibly null),
        /// - the keys currently logically down,
        /// - the active modifiers,
        /// - the active group.
        ///
        /// By default, the active surface is null, the keys currently logically down
        /// are empty, the active modifiers and the active group are 0.
        pub const Keyboard = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.keyboard.interface;
            pub const KeymapFormat = common.wl.keyboard.KeymapFormat;
            pub const KeyState = common.wl.keyboard.KeyState;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Keyboard {
                return @ptrCast(try server.wl.Resource.create(_client, Keyboard, _version, _id));
            }
            pub fn destroy(_keyboard: *Keyboard) void {
                return @as(*server.wl.Resource, @ptrCast(_keyboard)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Keyboard {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_keyboard: *Keyboard) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_keyboard)).getLink();
            }
            pub fn getClient(_keyboard: *Keyboard) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_keyboard)).getClient();
            }
            pub fn getId(_keyboard: *Keyboard) u32 {
                return @as(*server.wl.Resource, @ptrCast(_keyboard)).getId();
            }
            pub fn getVersion(_keyboard: *Keyboard) u32 {
                return @as(*server.wl.Resource, @ptrCast(_keyboard)).getVersion();
            }
            pub fn postNoMemory(_keyboard: *Keyboard) void {
                return @as(*server.wl.Resource, @ptrCast(_keyboard)).postNoMemory();
            }
            pub fn getUserData(_keyboard: *Keyboard) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_keyboard)).getUserData();
            }
            pub const Request = union(enum) {
                release: void,
            };
            pub inline fn setHandler(
                _keyboard: *Keyboard,
                comptime T: type,
                handle_request: *const fn (_keyboard: *Keyboard, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_keyboard: *Keyboard, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_keyboard);
                _resource.setDispatcher(
                    common.Dispatcher(Keyboard, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Keyboard, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// This event provides a file descriptor to the client which can be
            /// memory-mapped in read-only mode to provide a keyboard mapping
            /// description.
            ///
            /// From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
            /// the recipient, as MAP_SHARED may fail.
            pub fn sendKeymap(_keyboard: *Keyboard, _format: KeymapFormat, _fd: i32, _size: u32) void {
                const _resource: *server.wl.Resource = @ptrCast(_keyboard);
                var _args = [_]common.Argument{
                    .{ .u = switch (@typeInfo(KeymapFormat)) {
                        .@"enum" => @as(u32, @intCast(@intFromEnum(_format))),
                        .@"struct" => @bitCast(_format),
                        else => unreachable,
                    } },
                    .{ .h = _fd },
                    .{ .u = _size },
                };
                _resource.postEvent(0, &_args);
            }

            /// Notification that this seat's keyboard focus is on a certain
            /// surface.
            ///
            /// The compositor must send the wl_keyboard.modifiers event after this
            /// event.
            ///
            /// In the wl_keyboard logical state, this event sets the active surface to
            /// the surface argument and the keys currently logically down to the keys
            /// in the keys argument. The compositor must not send this event if the
            /// wl_keyboard already had an active surface immediately before this event.
            ///
            /// Clients should not use the list of pressed keys to emulate key-press
            /// events. The order of keys in the list is unspecified.
            pub fn sendEnter(_keyboard: *Keyboard, _serial: u32, _surface: *server.wl.Surface, _keys: *common.Array) void {
                const _resource: *server.wl.Resource = @ptrCast(_keyboard);
                var _args = [_]common.Argument{
                    .{ .u = _serial },
                    .{ .o = @ptrCast(_surface) },
                    .{ .a = _keys },
                };
                _resource.postEvent(1, &_args);
            }

            /// Notification that this seat's keyboard focus is no longer on
            /// a certain surface.
            ///
            /// The leave notification is sent before the enter notification
            /// for the new focus.
            ///
            /// In the wl_keyboard logical state, this event resets all values to their
            /// defaults. The compositor must not send this event if the active surface
            /// of the wl_keyboard was not equal to the surface argument immediately
            /// before this event.
            pub fn sendLeave(_keyboard: *Keyboard, _serial: u32, _surface: *server.wl.Surface) void {
                const _resource: *server.wl.Resource = @ptrCast(_keyboard);
                var _args = [_]common.Argument{
                    .{ .u = _serial },
                    .{ .o = @ptrCast(_surface) },
                };
                _resource.postEvent(2, &_args);
            }

            /// A key was pressed or released.
            /// The time argument is a timestamp with millisecond
            /// granularity, with an undefined base.
            ///
            /// The key is a platform-specific key code that can be interpreted
            /// by feeding it to the keyboard mapping (see the keymap event).
            ///
            /// If this event produces a change in modifiers, then the resulting
            /// wl_keyboard.modifiers event must be sent after this event.
            ///
            /// In the wl_keyboard logical state, this event adds the key to the keys
            /// currently logically down (if the state argument is pressed) or removes
            /// the key from the keys currently logically down (if the state argument is
            /// released). The compositor must not send this event if the wl_keyboard
            /// did not have an active surface immediately before this event. The
            /// compositor must not send this event if state is pressed (resp. released)
            /// and the key was already logically down (resp. was not logically down)
            /// immediately before this event.
            ///
            /// Since version 10, compositors may send key events with the "repeated"
            /// key state when a wl_keyboard.repeat_info event with a rate argument of
            /// 0 has been received. This allows the compositor to take over the
            /// responsibility of key repetition.
            pub fn sendKey(_keyboard: *Keyboard, _serial: u32, _time: u32, _key: u32, _state: KeyState) void {
                const _resource: *server.wl.Resource = @ptrCast(_keyboard);
                var _args = [_]common.Argument{
                    .{ .u = _serial },
                    .{ .u = _time },
                    .{ .u = _key },
                    .{ .u = switch (@typeInfo(KeyState)) {
                        .@"enum" => @as(u32, @intCast(@intFromEnum(_state))),
                        .@"struct" => @bitCast(_state),
                        else => unreachable,
                    } },
                };
                _resource.postEvent(3, &_args);
            }

            /// Notifies clients that the modifier and/or group state has
            /// changed, and it should update its local state.
            ///
            /// The compositor may send this event without a surface of the client
            /// having keyboard focus, for example to tie modifier information to
            /// pointer focus instead. If a modifier event with pressed modifiers is sent
            /// without a prior enter event, the client can assume the modifier state is
            /// valid until it receives the next wl_keyboard.modifiers event. In order to
            /// reset the modifier state again, the compositor can send a
            /// wl_keyboard.modifiers event with no pressed modifiers.
            ///
            /// In the wl_keyboard logical state, this event updates the modifiers and
            /// group.
            pub fn sendModifiers(_keyboard: *Keyboard, _serial: u32, _mods_depressed: u32, _mods_latched: u32, _mods_locked: u32, _group: u32) void {
                const _resource: *server.wl.Resource = @ptrCast(_keyboard);
                var _args = [_]common.Argument{
                    .{ .u = _serial },
                    .{ .u = _mods_depressed },
                    .{ .u = _mods_latched },
                    .{ .u = _mods_locked },
                    .{ .u = _group },
                };
                _resource.postEvent(4, &_args);
            }

            /// Informs the client about the keyboard's repeat rate and delay.
            ///
            /// This event is sent as soon as the wl_keyboard object has been created,
            /// and is guaranteed to be received by the client before any key press
            /// event.
            ///
            /// Negative values for either rate or delay are illegal. A rate of zero
            /// will disable any repeating (regardless of the value of delay).
            ///
            /// This event can be sent later on as well with a new value if necessary,
            /// so clients should continue listening for the event past the creation
            /// of wl_keyboard.
            pub fn sendRepeatInfo(_keyboard: *Keyboard, _rate: i32, _delay: i32) void {
                const _resource: *server.wl.Resource = @ptrCast(_keyboard);
                var _args = [_]common.Argument{
                    .{ .i = _rate },
                    .{ .i = _delay },
                };
                _resource.postEvent(5, &_args);
            }
        };

        /// The wl_touch interface represents a touchscreen
        /// associated with a seat.
        ///
        /// Touch interactions can consist of one or more contacts.
        /// For each contact, a series of events is generated, starting
        /// with a down event, followed by zero or more motion events,
        /// and ending with an up event. Events relating to the same
        /// contact point can be identified by the ID of the sequence.
        pub const Touch = opaque {
            pub const generated_version = 5;
            pub const interface = &common.wl.touch.interface;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Touch {
                return @ptrCast(try server.wl.Resource.create(_client, Touch, _version, _id));
            }
            pub fn destroy(_touch: *Touch) void {
                return @as(*server.wl.Resource, @ptrCast(_touch)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Touch {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_touch: *Touch) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_touch)).getLink();
            }
            pub fn getClient(_touch: *Touch) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_touch)).getClient();
            }
            pub fn getId(_touch: *Touch) u32 {
                return @as(*server.wl.Resource, @ptrCast(_touch)).getId();
            }
            pub fn getVersion(_touch: *Touch) u32 {
                return @as(*server.wl.Resource, @ptrCast(_touch)).getVersion();
            }
            pub fn postNoMemory(_touch: *Touch) void {
                return @as(*server.wl.Resource, @ptrCast(_touch)).postNoMemory();
            }
            pub fn getUserData(_touch: *Touch) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_touch)).getUserData();
            }
            pub const Request = union(enum) {
                release: void,
            };
            pub inline fn setHandler(
                _touch: *Touch,
                comptime T: type,
                handle_request: *const fn (_touch: *Touch, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_touch: *Touch, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_touch);
                _resource.setDispatcher(
                    common.Dispatcher(Touch, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Touch, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// A new touch point has appeared on the surface. This touch point is
            /// assigned a unique ID. Future events from this touch point reference
            /// this ID. The ID ceases to be valid after a touch up event and may be
            /// reused in the future.
            pub fn sendDown(_touch: *Touch, _serial: u32, _time: u32, _surface: *server.wl.Surface, _id: i32, _x: common.Fixed, _y: common.Fixed) void {
                const _resource: *server.wl.Resource = @ptrCast(_touch);
                var _args = [_]common.Argument{
                    .{ .u = _serial },
                    .{ .u = _time },
                    .{ .o = @ptrCast(_surface) },
                    .{ .i = _id },
                    .{ .f = _x },
                    .{ .f = _y },
                };
                _resource.postEvent(0, &_args);
            }

            /// The touch point has disappeared. No further events will be sent for
            /// this touch point and the touch point's ID is released and may be
            /// reused in a future touch down event.
            pub fn sendUp(_touch: *Touch, _serial: u32, _time: u32, _id: i32) void {
                const _resource: *server.wl.Resource = @ptrCast(_touch);
                var _args = [_]common.Argument{
                    .{ .u = _serial },
                    .{ .u = _time },
                    .{ .i = _id },
                };
                _resource.postEvent(1, &_args);
            }

            /// A touch point has changed coordinates.
            pub fn sendMotion(_touch: *Touch, _time: u32, _id: i32, _x: common.Fixed, _y: common.Fixed) void {
                const _resource: *server.wl.Resource = @ptrCast(_touch);
                var _args = [_]common.Argument{
                    .{ .u = _time },
                    .{ .i = _id },
                    .{ .f = _x },
                    .{ .f = _y },
                };
                _resource.postEvent(2, &_args);
            }

            /// Indicates the end of a set of events that logically belong together.
            /// A client is expected to accumulate the data in all events within the
            /// frame before proceeding.
            ///
            /// A wl_touch.frame terminates at least one event but otherwise no
            /// guarantee is provided about the set of events within a frame. A client
            /// must assume that any state not updated in a frame is unchanged from the
            /// previously known state.
            pub fn sendFrame(_touch: *Touch) void {
                const _resource: *server.wl.Resource = @ptrCast(_touch);
                _resource.postEvent(3, null);
            }

            /// Sent if the compositor decides the touch stream is a global
            /// gesture. No further events are sent to the clients from that
            /// particular gesture. Touch cancellation applies to all touch points
            /// currently active on this client's surface. The client is
            /// responsible for finalizing the touch points, future touch points on
            /// this surface may reuse the touch point ID.
            ///
            /// No frame event is required after the cancel event.
            pub fn sendCancel(_touch: *Touch) void {
                const _resource: *server.wl.Resource = @ptrCast(_touch);
                _resource.postEvent(4, null);
            }
        };

        /// An output describes part of the compositor geometry.  The
        /// compositor works in the 'compositor coordinate system' and an
        /// output corresponds to a rectangular area in that space that is
        /// actually visible.  This typically corresponds to a monitor that
        /// displays part of the compositor space.  This object is published
        /// as global during start up, or when a monitor is hotplugged.
        pub const Output = opaque {
            pub const generated_version = 4;
            pub const interface = &common.wl.output.interface;
            pub const Subpixel = common.wl.output.Subpixel;
            pub const Transform = common.wl.output.Transform;
            pub const Mode = common.wl.output.Mode;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Output {
                return @ptrCast(try server.wl.Resource.create(_client, Output, _version, _id));
            }
            pub fn destroy(_output: *Output) void {
                return @as(*server.wl.Resource, @ptrCast(_output)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Output {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_output: *Output) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_output)).getLink();
            }
            pub fn getClient(_output: *Output) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_output)).getClient();
            }
            pub fn getId(_output: *Output) u32 {
                return @as(*server.wl.Resource, @ptrCast(_output)).getId();
            }
            pub fn getVersion(_output: *Output) u32 {
                return @as(*server.wl.Resource, @ptrCast(_output)).getVersion();
            }
            pub fn postNoMemory(_output: *Output) void {
                return @as(*server.wl.Resource, @ptrCast(_output)).postNoMemory();
            }
            pub fn getUserData(_output: *Output) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_output)).getUserData();
            }
            pub const Request = union(enum) {
                /// Using this request a client can tell the server that it is not going to
                /// use the output object anymore.
                release: void,
            };
            pub inline fn setHandler(
                _output: *Output,
                comptime T: type,
                handle_request: *const fn (_output: *Output, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_output: *Output, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_output);
                _resource.setDispatcher(
                    common.Dispatcher(Output, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Output, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// The geometry event describes geometric properties of the output.
            /// The event is sent when binding to the output object and whenever
            /// any of the properties change.
            ///
            /// The physical size can be set to zero if it doesn't make sense for this
            /// output (e.g. for projectors or virtual outputs).
            ///
            /// The geometry event will be followed by a done event (starting from
            /// version 2).
            ///
            /// Clients should use wl_surface.preferred_buffer_transform instead of the
            /// transform advertised by this event to find the preferred buffer
            /// transform to use for a surface.
            ///
            /// Note: wl_output only advertises partial information about the output
            /// position and identification. Some compositors, for instance those not
            /// implementing a desktop-style output layout or those exposing virtual
            /// outputs, might fake this information. Instead of using x and y, clients
            /// should use xdg_output.logical_position. Instead of using make and model,
            /// clients should use name and description.
            pub fn sendGeometry(_output: *Output, _x: i32, _y: i32, _physical_width: i32, _physical_height: i32, _subpixel: Subpixel, _make: [*:0]const u8, _model: [*:0]const u8, _transform: Transform) void {
                const _resource: *server.wl.Resource = @ptrCast(_output);
                var _args = [_]common.Argument{
                    .{ .i = _x },
                    .{ .i = _y },
                    .{ .i = _physical_width },
                    .{ .i = _physical_height },
                    .{ .i = switch (@typeInfo(Subpixel)) {
                        .@"enum" => @as(i32, @intCast(@intFromEnum(_subpixel))),
                        .@"struct" => @bitCast(_subpixel),
                        else => unreachable,
                    } },
                    .{ .s = _make },
                    .{ .s = _model },
                    .{ .i = switch (@typeInfo(Transform)) {
                        .@"enum" => @as(i32, @intCast(@intFromEnum(_transform))),
                        .@"struct" => @bitCast(_transform),
                        else => unreachable,
                    } },
                };
                _resource.postEvent(0, &_args);
            }

            /// The mode event describes an available mode for the output.
            ///
            /// The event is sent when binding to the output object and there
            /// will always be one mode, the current mode.  The event is sent
            /// again if an output changes mode, for the mode that is now
            /// current.  In other words, the current mode is always the last
            /// mode that was received with the current flag set.
            ///
            /// Non-current modes are deprecated. A compositor can decide to only
            /// advertise the current mode and never send other modes. Clients
            /// should not rely on non-current modes.
            ///
            /// The size of a mode is given in physical hardware units of
            /// the output device. This is not necessarily the same as
            /// the output size in the global compositor space. For instance,
            /// the output may be scaled, as described in wl_output.scale,
            /// or transformed, as described in wl_output.transform. Clients
            /// willing to retrieve the output size in the global compositor
            /// space should use xdg_output.logical_size instead.
            ///
            /// The vertical refresh rate can be set to zero if it doesn't make
            /// sense for this output (e.g. for virtual outputs).
            ///
            /// The mode event will be followed by a done event (starting from
            /// version 2).
            ///
            /// Clients should not use the refresh rate to schedule frames. Instead,
            /// they should use the wl_surface.frame event or the presentation-time
            /// protocol.
            ///
            /// Note: this information is not always meaningful for all outputs. Some
            /// compositors, such as those exposing virtual outputs, might fake the
            /// refresh rate or the size.
            pub fn sendMode(_output: *Output, _flags: Mode, _width: i32, _height: i32, _refresh: i32) void {
                const _resource: *server.wl.Resource = @ptrCast(_output);
                var _args = [_]common.Argument{
                    .{ .u = switch (@typeInfo(Mode)) {
                        .@"enum" => @as(u32, @intCast(@intFromEnum(_flags))),
                        .@"struct" => @bitCast(_flags),
                        else => unreachable,
                    } },
                    .{ .i = _width },
                    .{ .i = _height },
                    .{ .i = _refresh },
                };
                _resource.postEvent(1, &_args);
            }

            /// This event is sent after all other properties have been
            /// sent after binding to the output object and after any
            /// other property changes done after that. This allows
            /// changes to the output properties to be seen as
            /// atomic, even if they happen via multiple events.
            pub fn sendDone(_output: *Output) void {
                const _resource: *server.wl.Resource = @ptrCast(_output);
                _resource.postEvent(2, null);
            }

            /// This event contains scaling geometry information
            /// that is not in the geometry event. It may be sent after
            /// binding the output object or if the output scale changes
            /// later. The compositor will emit a non-zero, positive
            /// value for scale. If it is not sent, the client should
            /// assume a scale of 1.
            ///
            /// A scale larger than 1 means that the compositor will
            /// automatically scale surface buffers by this amount
            /// when rendering. This is used for very high resolution
            /// displays where applications rendering at the native
            /// resolution would be too small to be legible.
            ///
            /// Clients should use wl_surface.preferred_buffer_scale
            /// instead of this event to find the preferred buffer
            /// scale to use for a surface.
            ///
            /// The scale event will be followed by a done event.
            pub fn sendScale(_output: *Output, _factor: i32) void {
                const _resource: *server.wl.Resource = @ptrCast(_output);
                var _args = [_]common.Argument{
                    .{ .i = _factor },
                };
                _resource.postEvent(3, &_args);
            }

            /// Many compositors will assign user-friendly names to their outputs, show
            /// them to the user, allow the user to refer to an output, etc. The client
            /// may wish to know this name as well to offer the user similar behaviors.
            ///
            /// The name is a UTF-8 string with no convention defined for its contents.
            /// Each name is unique among all wl_output globals. The name is only
            /// guaranteed to be unique for the compositor instance.
            ///
            /// The same output name is used for all clients for a given wl_output
            /// global. Thus, the name can be shared across processes to refer to a
            /// specific wl_output global.
            ///
            /// The name is not guaranteed to be persistent across sessions, thus cannot
            /// be used to reliably identify an output in e.g. configuration files.
            ///
            /// Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
            /// not assume that the name is a reflection of an underlying DRM connector,
            /// X11 connection, etc.
            ///
            /// The name event is sent after binding the output object. This event is
            /// only sent once per output object, and the name does not change over the
            /// lifetime of the wl_output global.
            ///
            /// Compositors may re-use the same output name if the wl_output global is
            /// destroyed and re-created later. Compositors should avoid re-using the
            /// same name if possible.
            ///
            /// The name event will be followed by a done event.
            pub fn sendName(_output: *Output, _name: [*:0]const u8) void {
                const _resource: *server.wl.Resource = @ptrCast(_output);
                var _args = [_]common.Argument{
                    .{ .s = _name },
                };
                _resource.postEvent(4, &_args);
            }

            /// Many compositors can produce human-readable descriptions of their
            /// outputs. The client may wish to know this description as well, e.g. for
            /// output selection purposes.
            ///
            /// The description is a UTF-8 string with no convention defined for its
            /// contents. The description is not guaranteed to be unique among all
            /// wl_output globals. Examples might include 'Foocorp 11" Display' or
            /// 'Virtual X11 output via :1'.
            ///
            /// The description event is sent after binding the output object and
            /// whenever the description changes. The description is optional, and may
            /// not be sent at all.
            ///
            /// The description event will be followed by a done event.
            pub fn sendDescription(_output: *Output, _description: [*:0]const u8) void {
                const _resource: *server.wl.Resource = @ptrCast(_output);
                var _args = [_]common.Argument{
                    .{ .s = _description },
                };
                _resource.postEvent(5, &_args);
            }
        };
    };
};

const common = struct {
    const Object = opaque {};

    const Message = extern struct {
        name: [*:0]const u8,
        signature: [*:0]const u8,
        types: ?[*]const ?*const Interface,
    };

    const Interface = extern struct {
        name: [*:0]const u8,
        version: c_int,
        method_count: c_int,
        methods: ?[*]const Message,
        event_count: c_int,
        events: ?[*]const Message,
    };

    const list = struct {
        pub const Link = extern struct {
            prev: ?*Link,
            next: ?*Link,

            pub fn init(link: *Link) void {
                link.* = .{ .prev = link, .next = link };
            }

            pub fn insert(link: *Link, other: *Link) void {
                other.prev = link;
                other.next = link.next;
                link.next = other;
                other.next.?.prev = other;
            }

            pub fn remove(link: *Link) void {
                link.prev.?.next = link.next;
                link.next.?.prev = link.prev;
                link.* = .{ .prev = null, .next = null };
            }

            pub fn replaceWith(link: *Link, other: *Link) void {
                other.next = link.next;
                other.next.?.prev = other;
                other.prev = link.prev;
                other.prev.?.next = other;

                link.* = .{ .prev = null, .next = null };
            }

            pub fn swapWith(link: *Link, other: *Link) void {
                const old_other_prev = other.prev.?;
                other.remove();

                link.replaceWith(other);

                if (old_other_prev == link) {
                    other.insert(link);
                } else {
                    old_other_prev.insert(link);
                }
            }

            /// private helper that doesn't handle empty lists and assumes that
            /// other is the link of a Head.
            fn insertList(link: *Link, other: *Link) void {
                other.next.?.prev = link;
                other.prev.?.next = link.next;
                link.next.?.prev = other.prev;
                link.next = other.next;

                other.init();
            }
        };

        pub const Direction = enum {
            forward,
            reverse,
        };

        /// This has the same ABI as wl.list.Link/wl_list. If link_field is null, then
        /// T.getLink()/T.fromLink() will be used. This allows for compatiability
        /// with wl.Client and wl.Resource
        pub fn Head(comptime T: type, comptime link_field: ?@Type(.enum_literal)) type {
            return extern struct {
                const Self = @This();

                link: Link,

                pub fn init(head: *Self) void {
                    head.link.init();
                }

                pub fn prepend(head: *Self, elem: *T) void {
                    head.link.insert(linkFromElem(elem));
                }

                pub fn append(head: *Self, elem: *T) void {
                    head.link.prev.?.insert(linkFromElem(elem));
                }

                pub fn prependList(head: *Self, other: *Self) void {
                    if (other.empty()) return;
                    head.link.insertList(&other.link);
                }

                pub fn appendList(head: *Self, other: *Self) void {
                    if (other.empty()) return;
                    head.link.prev.?.insertList(&other.link);
                }

                pub fn first(head: *Self) ?*T {
                    if (head.empty()) {
                        return null;
                    } else {
                        return elemFromLink(head.link.next.?);
                    }
                }

                pub fn last(head: *Self) ?*T {
                    if (head.empty()) {
                        return null;
                    } else {
                        return elemFromLink(head.link.prev.?);
                    }
                }

                pub fn length(head: *const Self) usize {
                    var count: usize = 0;
                    var current = head.link.next.?;
                    while (current != &head.link) : (current = current.next.?) {
                        count += 1;
                    }
                    return count;
                }

                pub fn empty(head: *const Self) bool {
                    return head.link.next == &head.link;
                }

                /// Removal of elements during iteration is illegal
                pub fn Iterator(comptime direction: Direction) type {
                    return struct {
                        head: *Link,
                        current: *Link,

                        pub fn next(it: *@This()) ?*T {
                            it.current = switch (direction) {
                                .forward => it.current.next.?,
                                .reverse => it.current.prev.?,
                            };
                            if (it.current == it.head) return null;
                            return elemFromLink(it.current);
                        }
                    };
                }

                /// Removal of elements during iteration is illegal
                pub fn iterator(head: *Self, comptime direction: Direction) Iterator(direction) {
                    return .{ .head = &head.link, .current = &head.link };
                }

                /// Removal of the current element during iteration is permitted.
                /// Removal of other elements is illegal.
                pub fn SafeIterator(comptime direction: Direction) type {
                    return struct {
                        head: *Link,
                        current: *Link,
                        future: *Link,

                        pub fn next(it: *@This()) ?*T {
                            it.current = it.future;
                            it.future = switch (direction) {
                                .forward => it.future.next.?,
                                .reverse => it.future.prev.?,
                            };
                            if (it.current == it.head) return null;
                            return elemFromLink(it.current);
                        }
                    };
                }

                /// Removal of the current element during iteration is permitted.
                /// Removal of other elements is illegal.
                pub fn safeIterator(head: *Self, comptime direction: Direction) SafeIterator(direction) {
                    return .{
                        .head = &head.link,
                        .current = &head.link,
                        .future = switch (direction) {
                            .forward => head.link.next.?,
                            .reverse => head.link.prev.?,
                        },
                    };
                }

                fn linkFromElem(elem: *T) *Link {
                    if (link_field) |f| {
                        return &@field(elem, @tagName(f));
                    } else {
                        return elem.getLink();
                    }
                }

                fn elemFromLink(link: *Link) *T {
                    if (link_field) |f| {
                        return @fieldParentPtr(@tagName(f), link);
                    } else {
                        return T.fromLink(link);
                    }
                }
            };
        }
    };

    const Array = extern struct {
        size: usize,
        alloc: usize,
        data: ?*anyopaque,

        /// Does not clone memory
        pub fn fromArrayList(comptime T: type, array_list: std.ArrayList(T)) Array {
            return Array{
                .size = array_list.items.len * @sizeOf(T),
                .alloc = array_list.capacity * @sizeOf(T),
                .data = array_list.items.ptr,
            };
        }

        pub fn slice(array: Array, comptime T: type) []align(4) T {
            const data = array.data orelse return &[0]T{};
            // The wire protocol/libwayland only guarantee 32-bit word alignment.
            const ptr: [*]align(4) T = @ptrCast(@alignCast(data));
            return ptr[0..@divExact(array.size, @sizeOf(T))];
        }
    };

    /// A 24.8 signed fixed-point number.
    const Fixed = enum(i32) {
        _,

        pub fn toInt(f: Fixed) i24 {
            return @truncate(@intFromEnum(f) >> 8);
        }

        pub fn fromInt(i: i24) Fixed {
            return @enumFromInt(@as(i32, i) << 8);
        }

        pub fn toDouble(f: Fixed) f64 {
            return @as(f64, @floatFromInt(@intFromEnum(f))) / 256;
        }

        pub fn fromDouble(d: f64) Fixed {
            return @enumFromInt(@as(i32, @intFromFloat(d * 256)));
        }
    };

    const Argument = extern union {
        i: i32,
        u: u32,
        f: Fixed,
        s: ?[*:0]const u8,
        o: ?*Object,
        n: u32,
        a: ?*Array,
        h: i32,
    };

    fn Dispatcher(comptime Obj: type, comptime Data: type) type {
        const client_side = @hasDecl(Obj, "Event");
        const Payload = if (client_side) Obj.Event else Obj.Request;
        return struct {
            fn dispatcher(
                implementation: ?*const anyopaque,
                object: if (client_side) *client.wl.Proxy else *server.wl.Resource,
                opcode: u32,
                _: *const Message,
                args: [*]Argument,
            ) callconv(.c) c_int {
                inline for (@typeInfo(Payload).@"union".fields, 0..) |payload_field, payload_num| {
                    if (payload_num == opcode) {
                        var payload_data: payload_field.type = undefined;
                        if (payload_field.type != void) {
                            inline for (@typeInfo(payload_field.type).@"struct".fields, 0..) |f, i| {
                                switch (@typeInfo(f.type)) {
                                    // signed/unsigned ints, fds, new_ids, bitfield enums
                                    .int, .@"struct" => @field(payload_data, f.name) = @as(f.type, @bitCast(args[i].u)),
                                    // objects, strings, arrays
                                    .pointer, .optional => @field(payload_data, f.name) = @as(f.type, @ptrFromInt(@intFromPtr(args[i].o))),
                                    // non-bitfield enums
                                    .@"enum" => @field(payload_data, f.name) = @as(f.type, @enumFromInt(args[i].i)),
                                    else => unreachable,
                                }
                            }
                        }

                        const HandlerFn = fn (*Obj, Payload, Data) void;
                        @as(*const HandlerFn, @ptrCast(@alignCast(implementation)))(
                            @as(*Obj, @ptrCast(object)),
                            @unionInit(Payload, payload_field.name, payload_data),
                            @as(Data, @ptrFromInt(@intFromPtr(object.getUserData()))),
                        );

                        return 0;
                    }
                }
                unreachable;
            }
        };
    }
    const wl = struct {
        const display = struct {
            const interface: common.Interface = .{
                .name = "wl_display",
                .version = 1,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "sync",
                        .signature = "n",
                        .types = &.{
                            &common.wl.callback.interface,
                        },
                    },
                    .{
                        .name = "get_registry",
                        .signature = "n",
                        .types = &.{
                            &common.wl.registry.interface,
                        },
                    },
                },
                .event_count = 2,
                .events = &.{
                    .{
                        .name = "error",
                        .signature = "ous",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "delete_id",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
            /// These errors are global and can be emitted in response to any
            /// server request.
            const Error = enum(c_int) {
                invalid_object = 0,
                invalid_method = 1,
                no_memory = 2,
                implementation = 3,
                _,
            };
        };
        const registry = struct {
            const interface: common.Interface = .{
                .name = "wl_registry",
                .version = 1,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "bind",
                        .signature = "usun",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                },
                .event_count = 2,
                .events = &.{
                    .{
                        .name = "global",
                        .signature = "usu",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "global_remove",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const callback = struct {
            const interface: common.Interface = .{
                .name = "wl_callback",
                .version = 1,
                .method_count = 0,
                .methods = null,
                .event_count = 1,
                .events = &.{
                    .{
                        .name = "done",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const buffer = struct {
            const interface: common.Interface = .{
                .name = "wl_buffer",
                .version = 1,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                },
                .event_count = 1,
                .events = &.{
                    .{
                        .name = "release",
                        .signature = "",
                        .types = null,
                    },
                },
            };
        };
        const compositor = struct {
            const interface: common.Interface = .{
                .name = "wl_compositor",
                .version = 6,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "create_surface",
                        .signature = "n",
                        .types = &.{
                            &common.wl.surface.interface,
                        },
                    },
                    .{
                        .name = "create_region",
                        .signature = "n",
                        .types = &.{
                            &common.wl.region.interface,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const surface = struct {
            const interface: common.Interface = .{
                .name = "wl_surface",
                .version = 6,
                .method_count = 11,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "attach",
                        .signature = "?oii",
                        .types = &.{
                            &common.wl.buffer.interface,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "damage",
                        .signature = "iiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "frame",
                        .signature = "n",
                        .types = &.{
                            &common.wl.callback.interface,
                        },
                    },
                    .{
                        .name = "set_opaque_region",
                        .signature = "?o",
                        .types = &.{
                            &common.wl.region.interface,
                        },
                    },
                    .{
                        .name = "set_input_region",
                        .signature = "?o",
                        .types = &.{
                            &common.wl.region.interface,
                        },
                    },
                    .{
                        .name = "commit",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "set_buffer_transform",
                        .signature = "2i",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "set_buffer_scale",
                        .signature = "3i",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "damage_buffer",
                        .signature = "4iiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "offset",
                        .signature = "5ii",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
                .event_count = 4,
                .events = &.{
                    .{
                        .name = "enter",
                        .signature = "o",
                        .types = &.{
                            &common.wl.output.interface,
                        },
                    },
                    .{
                        .name = "leave",
                        .signature = "o",
                        .types = &.{
                            &common.wl.output.interface,
                        },
                    },
                    .{
                        .name = "preferred_buffer_scale",
                        .signature = "6i",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "preferred_buffer_transform",
                        .signature = "6u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
            /// These errors can be emitted in response to wl_surface requests.
            const Error = enum(c_int) {
                invalid_scale = 0,
                invalid_transform = 1,
                invalid_size = 2,
                invalid_offset = 3,
                defunct_role_object = 4,
                _,
            };
        };
        const region = struct {
            const interface: common.Interface = .{
                .name = "wl_region",
                .version = 1,
                .method_count = 3,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "add",
                        .signature = "iiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "subtract",
                        .signature = "iiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const shm = struct {
            const interface: common.Interface = .{
                .name = "wl_shm",
                .version = 2,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "create_pool",
                        .signature = "nhi",
                        .types = &.{
                            &common.wl.shm_pool.interface,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "release",
                        .signature = "2",
                        .types = null,
                    },
                },
                .event_count = 1,
                .events = &.{
                    .{
                        .name = "format",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
            /// These errors can be emitted in response to wl_shm requests.
            const Error = enum(c_int) {
                invalid_format = 0,
                invalid_stride = 1,
                invalid_fd = 2,
                _,
            };

            /// This describes the memory layout of an individual pixel.
            ///
            /// All renderers should support argb8888 and xrgb8888 but any other
            /// formats are optional and may not be supported by the particular
            /// renderer in use.
            ///
            /// The drm format codes match the macros defined in drm_fourcc.h, except
            /// argb8888 and xrgb8888. The formats actually supported by the compositor
            /// will be reported by the format event.
            ///
            /// For all wl_shm formats and unless specified in another protocol
            /// extension, pre-multiplied alpha is used for pixel values.
            const Format = enum(c_int) {
                argb8888 = 0,
                xrgb8888 = 1,
                c8 = 0x20203843,
                rgb332 = 0x38424752,
                bgr233 = 0x38524742,
                xrgb4444 = 0x32315258,
                xbgr4444 = 0x32314258,
                rgbx4444 = 0x32315852,
                bgrx4444 = 0x32315842,
                argb4444 = 0x32315241,
                abgr4444 = 0x32314241,
                rgba4444 = 0x32314152,
                bgra4444 = 0x32314142,
                xrgb1555 = 0x35315258,
                xbgr1555 = 0x35314258,
                rgbx5551 = 0x35315852,
                bgrx5551 = 0x35315842,
                argb1555 = 0x35315241,
                abgr1555 = 0x35314241,
                rgba5551 = 0x35314152,
                bgra5551 = 0x35314142,
                rgb565 = 0x36314752,
                bgr565 = 0x36314742,
                rgb888 = 0x34324752,
                bgr888 = 0x34324742,
                xbgr8888 = 0x34324258,
                rgbx8888 = 0x34325852,
                bgrx8888 = 0x34325842,
                abgr8888 = 0x34324241,
                rgba8888 = 0x34324152,
                bgra8888 = 0x34324142,
                xrgb2101010 = 0x30335258,
                xbgr2101010 = 0x30334258,
                rgbx1010102 = 0x30335852,
                bgrx1010102 = 0x30335842,
                argb2101010 = 0x30335241,
                abgr2101010 = 0x30334241,
                rgba1010102 = 0x30334152,
                bgra1010102 = 0x30334142,
                yuyv = 0x56595559,
                yvyu = 0x55595659,
                uyvy = 0x59565955,
                vyuy = 0x59555956,
                ayuv = 0x56555941,
                nv12 = 0x3231564e,
                nv21 = 0x3132564e,
                nv16 = 0x3631564e,
                nv61 = 0x3136564e,
                yuv410 = 0x39565559,
                yvu410 = 0x39555659,
                yuv411 = 0x31315559,
                yvu411 = 0x31315659,
                yuv420 = 0x32315559,
                yvu420 = 0x32315659,
                yuv422 = 0x36315559,
                yvu422 = 0x36315659,
                yuv444 = 0x34325559,
                yvu444 = 0x34325659,
                r8 = 0x20203852,
                r16 = 0x20363152,
                rg88 = 0x38384752,
                gr88 = 0x38385247,
                rg1616 = 0x32334752,
                gr1616 = 0x32335247,
                xrgb16161616f = 0x48345258,
                xbgr16161616f = 0x48344258,
                argb16161616f = 0x48345241,
                abgr16161616f = 0x48344241,
                xyuv8888 = 0x56555958,
                vuy888 = 0x34325556,
                vuy101010 = 0x30335556,
                y210 = 0x30313259,
                y212 = 0x32313259,
                y216 = 0x36313259,
                y410 = 0x30313459,
                y412 = 0x32313459,
                y416 = 0x36313459,
                xvyu2101010 = 0x30335658,
                xvyu12_16161616 = 0x36335658,
                xvyu16161616 = 0x38345658,
                y0l0 = 0x304c3059,
                x0l0 = 0x304c3058,
                y0l2 = 0x324c3059,
                x0l2 = 0x324c3058,
                yuv420_8bit = 0x38305559,
                yuv420_10bit = 0x30315559,
                xrgb8888_a8 = 0x38415258,
                xbgr8888_a8 = 0x38414258,
                rgbx8888_a8 = 0x38415852,
                bgrx8888_a8 = 0x38415842,
                rgb888_a8 = 0x38413852,
                bgr888_a8 = 0x38413842,
                rgb565_a8 = 0x38413552,
                bgr565_a8 = 0x38413542,
                nv24 = 0x3432564e,
                nv42 = 0x3234564e,
                p210 = 0x30313250,
                p010 = 0x30313050,
                p012 = 0x32313050,
                p016 = 0x36313050,
                axbxgxrx106106106106 = 0x30314241,
                nv15 = 0x3531564e,
                q410 = 0x30313451,
                q401 = 0x31303451,
                xrgb16161616 = 0x38345258,
                xbgr16161616 = 0x38344258,
                argb16161616 = 0x38345241,
                abgr16161616 = 0x38344241,
                c1 = 0x20203143,
                c2 = 0x20203243,
                c4 = 0x20203443,
                d1 = 0x20203144,
                d2 = 0x20203244,
                d4 = 0x20203444,
                d8 = 0x20203844,
                r1 = 0x20203152,
                r2 = 0x20203252,
                r4 = 0x20203452,
                r10 = 0x20303152,
                r12 = 0x20323152,
                avuy8888 = 0x59555641,
                xvuy8888 = 0x59555658,
                p030 = 0x30333050,
                _,
            };
        };
        const shm_pool = struct {
            const interface: common.Interface = .{
                .name = "wl_shm_pool",
                .version = 2,
                .method_count = 3,
                .methods = &.{
                    .{
                        .name = "create_buffer",
                        .signature = "niiiiu",
                        .types = &.{
                            &common.wl.buffer.interface,
                            null,
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "resize",
                        .signature = "i",
                        .types = &.{
                            null,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const data_device_manager = struct {
            const interface: common.Interface = .{
                .name = "wl_data_device_manager",
                .version = 3,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "create_data_source",
                        .signature = "n",
                        .types = &.{
                            &common.wl.data_source.interface,
                        },
                    },
                    .{
                        .name = "get_data_device",
                        .signature = "no",
                        .types = &.{
                            &common.wl.data_device.interface,
                            &common.wl.seat.interface,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const data_source = struct {
            const interface: common.Interface = .{
                .name = "wl_data_source",
                .version = 3,
                .method_count = 3,
                .methods = &.{
                    .{
                        .name = "offer",
                        .signature = "s",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "set_actions",
                        .signature = "3u",
                        .types = &.{
                            null,
                        },
                    },
                },
                .event_count = 6,
                .events = &.{
                    .{
                        .name = "target",
                        .signature = "?s",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "send",
                        .signature = "sh",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "cancelled",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "dnd_drop_performed",
                        .signature = "3",
                        .types = null,
                    },
                    .{
                        .name = "dnd_finished",
                        .signature = "3",
                        .types = null,
                    },
                    .{
                        .name = "action",
                        .signature = "3u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const data_device = struct {
            const interface: common.Interface = .{
                .name = "wl_data_device",
                .version = 3,
                .method_count = 3,
                .methods = &.{
                    .{
                        .name = "start_drag",
                        .signature = "?oo?ou",
                        .types = &.{
                            &common.wl.data_source.interface,
                            &common.wl.surface.interface,
                            &common.wl.surface.interface,
                            null,
                        },
                    },
                    .{
                        .name = "set_selection",
                        .signature = "?ou",
                        .types = &.{
                            &common.wl.data_source.interface,
                            null,
                        },
                    },
                    .{
                        .name = "release",
                        .signature = "2",
                        .types = null,
                    },
                },
                .event_count = 6,
                .events = &.{
                    .{
                        .name = "data_offer",
                        .signature = "n",
                        .types = &.{
                            &common.wl.data_offer.interface,
                        },
                    },
                    .{
                        .name = "enter",
                        .signature = "uoff?o",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                            null,
                            null,
                            &common.wl.data_offer.interface,
                        },
                    },
                    .{
                        .name = "leave",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "motion",
                        .signature = "uff",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "drop",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "selection",
                        .signature = "?o",
                        .types = &.{
                            &common.wl.data_offer.interface,
                        },
                    },
                },
            };
        };
        const data_offer = struct {
            const interface: common.Interface = .{
                .name = "wl_data_offer",
                .version = 3,
                .method_count = 5,
                .methods = &.{
                    .{
                        .name = "accept",
                        .signature = "u?s",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "receive",
                        .signature = "sh",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "finish",
                        .signature = "3",
                        .types = null,
                    },
                    .{
                        .name = "set_actions",
                        .signature = "3uu",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
                .event_count = 3,
                .events = &.{
                    .{
                        .name = "offer",
                        .signature = "s",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "source_actions",
                        .signature = "3u",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "action",
                        .signature = "3u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const shell = struct {
            const interface: common.Interface = .{
                .name = "wl_shell",
                .version = 1,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "get_shell_surface",
                        .signature = "no",
                        .types = &.{
                            &common.wl.shell_surface.interface,
                            &common.wl.surface.interface,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const shell_surface = struct {
            const interface: common.Interface = .{
                .name = "wl_shell_surface",
                .version = 1,
                .method_count = 10,
                .methods = &.{
                    .{
                        .name = "pong",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "move",
                        .signature = "ou",
                        .types = &.{
                            &common.wl.seat.interface,
                            null,
                        },
                    },
                    .{
                        .name = "resize",
                        .signature = "ouu",
                        .types = &.{
                            &common.wl.seat.interface,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "set_toplevel",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "set_transient",
                        .signature = "oiiu",
                        .types = &.{
                            &common.wl.surface.interface,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "set_fullscreen",
                        .signature = "uu?o",
                        .types = &.{
                            null,
                            null,
                            &common.wl.output.interface,
                        },
                    },
                    .{
                        .name = "set_popup",
                        .signature = "ouoiiu",
                        .types = &.{
                            &common.wl.seat.interface,
                            null,
                            &common.wl.surface.interface,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "set_maximized",
                        .signature = "?o",
                        .types = &.{
                            &common.wl.output.interface,
                        },
                    },
                    .{
                        .name = "set_title",
                        .signature = "s",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "set_class",
                        .signature = "s",
                        .types = &.{
                            null,
                        },
                    },
                },
                .event_count = 3,
                .events = &.{
                    .{
                        .name = "ping",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "configure",
                        .signature = "uii",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "popup_done",
                        .signature = "",
                        .types = null,
                    },
                },
            };
        };
        const seat = struct {
            const interface: common.Interface = .{
                .name = "wl_seat",
                .version = 10,
                .method_count = 4,
                .methods = &.{
                    .{
                        .name = "get_pointer",
                        .signature = "n",
                        .types = &.{
                            &common.wl.pointer.interface,
                        },
                    },
                    .{
                        .name = "get_keyboard",
                        .signature = "n",
                        .types = &.{
                            &common.wl.keyboard.interface,
                        },
                    },
                    .{
                        .name = "get_touch",
                        .signature = "n",
                        .types = &.{
                            &common.wl.touch.interface,
                        },
                    },
                    .{
                        .name = "release",
                        .signature = "5",
                        .types = null,
                    },
                },
                .event_count = 2,
                .events = &.{
                    .{
                        .name = "capabilities",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "name",
                        .signature = "2s",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
            /// This is a bitmask of capabilities this seat has; if a member is
            /// set, then it is present on the seat.
            const Capability = packed struct(u32) {
                pointer: bool = false,
                keyboard: bool = false,
                touch: bool = false,
                _padding3: bool = false,
                _padding4: bool = false,
                _padding5: bool = false,
                _padding6: bool = false,
                _padding7: bool = false,
                _padding8: bool = false,
                _padding9: bool = false,
                _padding10: bool = false,
                _padding11: bool = false,
                _padding12: bool = false,
                _padding13: bool = false,
                _padding14: bool = false,
                _padding15: bool = false,
                _padding16: bool = false,
                _padding17: bool = false,
                _padding18: bool = false,
                _padding19: bool = false,
                _padding20: bool = false,
                _padding21: bool = false,
                _padding22: bool = false,
                _padding23: bool = false,
                _padding24: bool = false,
                _padding25: bool = false,
                _padding26: bool = false,
                _padding27: bool = false,
                _padding28: bool = false,
                _padding29: bool = false,
                _padding30: bool = false,
                _padding31: bool = false,
                pub const Enum = enum(c_int) {
                    pointer = 1,
                    keyboard = 2,
                    touch = 4,
                    _,
                };
            };

            /// These errors can be emitted in response to wl_seat requests.
            const Error = enum(c_int) {
                missing_capability = 0,
                _,
            };
        };
        const pointer = struct {
            const interface: common.Interface = .{
                .name = "wl_pointer",
                .version = 10,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "set_cursor",
                        .signature = "u?oii",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "release",
                        .signature = "3",
                        .types = null,
                    },
                },
                .event_count = 11,
                .events = &.{
                    .{
                        .name = "enter",
                        .signature = "uoff",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "leave",
                        .signature = "uo",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                        },
                    },
                    .{
                        .name = "motion",
                        .signature = "uff",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "button",
                        .signature = "uuuu",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "axis",
                        .signature = "uuf",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "frame",
                        .signature = "5",
                        .types = null,
                    },
                    .{
                        .name = "axis_source",
                        .signature = "5u",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "axis_stop",
                        .signature = "5uu",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "axis_discrete",
                        .signature = "5ui",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "axis_value120",
                        .signature = "8ui",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "axis_relative_direction",
                        .signature = "9uu",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
            };
            const Error = enum(c_int) {
                role = 0,
                _,
            };

            /// Describes the physical state of a button that produced the button
            /// event.
            const ButtonState = enum(c_int) {
                released = 0,
                pressed = 1,
                _,
            };

            /// Describes the axis types of scroll events.
            const Axis = enum(c_int) {
                vertical_scroll = 0,
                horizontal_scroll = 1,
                _,
            };

            /// Describes the source types for axis events. This indicates to the
            /// client how an axis event was physically generated; a client may
            /// adjust the user interface accordingly. For example, scroll events
            /// from a "finger" source may be in a smooth coordinate space with
            /// kinetic scrolling whereas a "wheel" source may be in discrete steps
            /// of a number of lines.
            ///
            /// The "continuous" axis source is a device generating events in a
            /// continuous coordinate space, but using something other than a
            /// finger. One example for this source is button-based scrolling where
            /// the vertical motion of a device is converted to scroll events while
            /// a button is held down.
            ///
            /// The "wheel tilt" axis source indicates that the actual device is a
            /// wheel but the scroll event is not caused by a rotation but a
            /// (usually sideways) tilt of the wheel.
            const AxisSource = enum(c_int) {
                wheel = 0,
                finger = 1,
                continuous = 2,
                _,
            };

            /// This specifies the direction of the physical motion that caused a
            /// wl_pointer.axis event, relative to the wl_pointer.axis direction.
            const AxisRelativeDirection = enum(c_int) {
                identical = 0,
                inverted = 1,
                _,
            };
        };
        const keyboard = struct {
            const interface: common.Interface = .{
                .name = "wl_keyboard",
                .version = 10,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "release",
                        .signature = "3",
                        .types = null,
                    },
                },
                .event_count = 6,
                .events = &.{
                    .{
                        .name = "keymap",
                        .signature = "uhu",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "enter",
                        .signature = "uoa",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                            null,
                        },
                    },
                    .{
                        .name = "leave",
                        .signature = "uo",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                        },
                    },
                    .{
                        .name = "key",
                        .signature = "uuuu",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "modifiers",
                        .signature = "uuuuu",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "repeat_info",
                        .signature = "4ii",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
            };
            /// This specifies the format of the keymap provided to the
            /// client with the wl_keyboard.keymap event.
            const KeymapFormat = enum(c_int) {
                no_keymap = 0,
                xkb_v1 = 1,
                _,
            };

            /// Describes the physical state of a key that produced the key event.
            ///
            /// Since version 10, the key can be in a "repeated" pseudo-state which
            /// means the same as "pressed", but is used to signal repetition in the
            /// key event.
            ///
            /// The key may only enter the repeated state after entering the pressed
            /// state and before entering the released state. This event may be
            /// generated multiple times while the key is down.
            const KeyState = enum(c_int) {
                released = 0,
                pressed = 1,
                _,
            };
        };
        const touch = struct {
            const interface: common.Interface = .{
                .name = "wl_touch",
                .version = 10,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "release",
                        .signature = "3",
                        .types = null,
                    },
                },
                .event_count = 7,
                .events = &.{
                    .{
                        .name = "down",
                        .signature = "uuoiff",
                        .types = &.{
                            null,
                            null,
                            &common.wl.surface.interface,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "up",
                        .signature = "uui",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "motion",
                        .signature = "uiff",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "frame",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "cancel",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "shape",
                        .signature = "6iff",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "orientation",
                        .signature = "6if",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
            };
        };
        const output = struct {
            const interface: common.Interface = .{
                .name = "wl_output",
                .version = 4,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "release",
                        .signature = "3",
                        .types = null,
                    },
                },
                .event_count = 6,
                .events = &.{
                    .{
                        .name = "geometry",
                        .signature = "iiiiissi",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "mode",
                        .signature = "uiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "done",
                        .signature = "2",
                        .types = null,
                    },
                    .{
                        .name = "scale",
                        .signature = "2i",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "name",
                        .signature = "4s",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "description",
                        .signature = "4s",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
            /// This enumeration describes how the physical
            /// pixels on an output are laid out.
            const Subpixel = enum(c_int) {
                unknown = 0,
                none = 1,
                horizontal_rgb = 2,
                horizontal_bgr = 3,
                vertical_rgb = 4,
                vertical_bgr = 5,
                _,
            };

            /// This describes transformations that clients and compositors apply to
            /// buffer contents.
            ///
            /// The flipped values correspond to an initial flip around a
            /// vertical axis followed by rotation.
            ///
            /// The purpose is mainly to allow clients to render accordingly and
            /// tell the compositor, so that for fullscreen surfaces, the
            /// compositor will still be able to scan out directly from client
            /// surfaces.
            const Transform = enum(c_int) {
                normal = 0,
                @"90" = 1,
                @"180" = 2,
                @"270" = 3,
                flipped = 4,
                flipped_90 = 5,
                flipped_180 = 6,
                flipped_270 = 7,
                _,
            };

            /// These flags describe properties of an output mode.
            /// They are used in the flags bitfield of the mode event.
            const Mode = packed struct(u32) {
                current: bool = false,
                preferred: bool = false,
                _padding2: bool = false,
                _padding3: bool = false,
                _padding4: bool = false,
                _padding5: bool = false,
                _padding6: bool = false,
                _padding7: bool = false,
                _padding8: bool = false,
                _padding9: bool = false,
                _padding10: bool = false,
                _padding11: bool = false,
                _padding12: bool = false,
                _padding13: bool = false,
                _padding14: bool = false,
                _padding15: bool = false,
                _padding16: bool = false,
                _padding17: bool = false,
                _padding18: bool = false,
                _padding19: bool = false,
                _padding20: bool = false,
                _padding21: bool = false,
                _padding22: bool = false,
                _padding23: bool = false,
                _padding24: bool = false,
                _padding25: bool = false,
                _padding26: bool = false,
                _padding27: bool = false,
                _padding28: bool = false,
                _padding29: bool = false,
                _padding30: bool = false,
                _padding31: bool = false,
                pub const Enum = enum(c_int) {
                    current = 0x1,
                    preferred = 0x2,
                    _,
                };
            };
        };
        const subcompositor = struct {
            const interface: common.Interface = .{
                .name = "wl_subcompositor",
                .version = 1,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "get_subsurface",
                        .signature = "noo",
                        .types = &.{
                            &common.wl.subsurface.interface,
                            &common.wl.surface.interface,
                            &common.wl.surface.interface,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const subsurface = struct {
            const interface: common.Interface = .{
                .name = "wl_subsurface",
                .version = 1,
                .method_count = 6,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "set_position",
                        .signature = "ii",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "place_above",
                        .signature = "o",
                        .types = &.{
                            &common.wl.surface.interface,
                        },
                    },
                    .{
                        .name = "place_below",
                        .signature = "o",
                        .types = &.{
                            &common.wl.surface.interface,
                        },
                    },
                    .{
                        .name = "set_sync",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "set_desync",
                        .signature = "",
                        .types = null,
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const fixes = struct {
            const interface: common.Interface = .{
                .name = "wl_fixes",
                .version = 1,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "destroy_registry",
                        .signature = "o",
                        .types = &.{
                            &common.wl.registry.interface,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
    };
};
